using CodeSparkNET.Models;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;

namespace CodeSparkNET.Data
{
    public class AppDbContext : IdentityDbContext<AppUser, IdentityRole, string>
    {
        public AppDbContext(DbContextOptions<AppDbContext> options)
            : base(options)
        {
        }

        public DbSet<ProductImage> ProductImages { get; set; } = null!;
        public DbSet<Catalog> Catalogs { get; set; } = null!;
        public DbSet<Course> Courses { get; set; } = null!;
        public DbSet<CourseModule> CourseModules { get; set; } = null!;
        public DbSet<Lesson> Lessons { get; set; } = null!;
        public DbSet<LessonResource> LessonResources { get; set; } = null!;
        public DbSet<Template> Templates { get; set; } = null!;
        public DbSet<Diploma> Diplomas { get; set; } = null!;
        public DbSet<UserCourse> UserCourses { get; set; } = null!;
        public DbSet<Product> Products { get; set; } = null!;

        protected override void OnModelCreating(ModelBuilder builder)
        {
            base.OnModelCreating(builder);

            // --- Roles seed ---
            var roles = new List<IdentityRole>
            {
                new IdentityRole
                {
                    Id = "a3f9c6d2-1f4b-4b8e-9f2a-111111111111",
                    Name = "Admin",
                    NormalizedName = "ADMIN",
                    ConcurrencyStamp = "c1f9c6d2-1f4b-4b8e-9f2a-111111111111"
                },
                new IdentityRole
                {
                    Id = "b4f9c6d2-2f4b-4b8e-9f2a-222222222222",
                    Name = "User",
                    NormalizedName = "USER",
                    ConcurrencyStamp = "d2f9c6d2-2f4b-4b8e-9f2a-222222222222"
                },
                new IdentityRole
                {
                    Id = "c5f9c6d2-3f4b-4b8e-9f2a-333333333333",
                    Name = "Prime",
                    NormalizedName = "PRIME",
                    ConcurrencyStamp = "e3f9c6d2-3f4b-4b8e-9f2a-333333333333"
                }
            };
            builder.Entity<IdentityRole>().HasData(roles);

            // --- Catalog ---
            builder.Entity<Catalog>(entity =>
            {
                entity.HasKey(c => c.Id);
                entity.Property(c => c.Name).IsRequired();
                entity.Property(c => c.Slug).IsRequired();
                entity.HasIndex(c => c.Slug).IsUnique();
                entity.Property(c => c.IsVisible).HasDefaultValue(true);
            });

            // --- Product (base type) ---
            builder.Entity<Product>(entity =>
            {
                entity.HasKey(p => p.Id);

                entity.Property(p => p.Name).IsRequired();
                entity.Property(p => p.Slug).IsRequired();
                entity.HasIndex(p => p.Slug).IsUnique();

                entity.Property(p => p.Price).HasColumnType("decimal(18,2)");
                entity.HasIndex(p => p.Price);

                entity.HasIndex(p => new { p.CatalogId, p.Slug }).IsUnique();

                entity.HasOne(p => p.Catalog)
                      .WithMany(cat => cat.Products)
                      .HasForeignKey(p => p.CatalogId)
                      .OnDelete(DeleteBehavior.Restrict);

                entity.HasMany(p => p.ProductImages)
                      .WithOne(pi => pi.Product)
                      .HasForeignKey(pi => pi.ProductId)
                      .OnDelete(DeleteBehavior.Restrict);

                entity.HasDiscriminator(p => p.ProductType)
                      .HasValue<Product>("Product")
                      .HasValue<Course>("Course")
                      .HasValue<Template>("Template")
                      .HasValue<Diploma>("Diploma");
            });

            // --- Course (derived) ---
            builder.Entity<Course>(entity =>
            {
                entity.Property(c => c.Level).HasMaxLength(100);

                entity.HasMany(c => c.UserCourses)
                      .WithOne(uc => uc.Course)
                      .HasForeignKey(uc => uc.CourseSlug)
                      .HasPrincipalKey(c => c.Slug);
            });

            // --- Template (derived) ---
            builder.Entity<Template>(entity =>
            {
            });

            // --- Diploma (derived) ---
            builder.Entity<Diploma>(entity =>
            {
                entity.Property(d => d.Issuer).HasMaxLength(200);
            });

            // --- Tutorial (derived) ---
            builder.Entity<Tutorial>(entity =>
            {
            });

            // --- UserCourse ---
            builder.Entity<UserCourse>(entity =>
            {
                entity.HasKey(uc => uc.Id);

                entity.Property(uc => uc.UserId).IsRequired();
                entity.Property(uc => uc.CourseSlug).IsRequired();

                entity.HasOne(uc => uc.User)
                      .WithMany()
                      .HasForeignKey(uc => uc.UserId)
                      .OnDelete(DeleteBehavior.Cascade);

                entity.HasIndex(uc => new { uc.UserId, uc.CourseSlug }).IsUnique(false);
            });

            // --- ProductImage ---
            builder.Entity<ProductImage>(entity =>
            {
                entity.HasKey(pi => pi.Id);
                entity.Property(pi => pi.ProductId).IsRequired();
                entity.Property(pi => pi.Name).IsRequired(false);

                entity.HasOne(pi => pi.Product)
                      .WithMany(p => p.ProductImages)
                      .HasForeignKey(pi => pi.ProductId)
                      .OnDelete(DeleteBehavior.Restrict);
            });

            // --- CourseModule ---
            builder.Entity<CourseModule>(entity =>
            {
                entity.HasKey(m => m.Id);

                entity.Property(m => m.Title).IsRequired().HasMaxLength(300);
                entity.Property(m => m.Position).HasDefaultValue(0);

                // CourseId -> Course.Id
                entity.HasOne(m => m.Course)
                      .WithMany(c => c.Modules)
                      .HasForeignKey(m => m.CourseId)
                      .OnDelete(DeleteBehavior.Cascade);

                entity.HasIndex(m => m.CourseId);
            });

            // --- Lesson ---
            builder.Entity<Lesson>(entity =>
            {
                entity.HasKey(l => l.Id);

                entity.Property(l => l.Title).IsRequired().HasMaxLength(400);
                entity.Property(l => l.Slug).HasMaxLength(400);
                entity.Property(l => l.Position).HasDefaultValue(0);
                entity.Property(l => l.IsPublished).HasDefaultValue(true);
                entity.Property(l => l.IsFreePreview).HasDefaultValue(false);

                entity.HasOne(l => l.Module)
                      .WithMany(m => m.Lessons)
                      .HasForeignKey(l => l.ModuleId)
                      .OnDelete(DeleteBehavior.Cascade);

                entity.HasIndex(l => l.ModuleId);
            });

            // --- LessonResource ---
            builder.Entity<LessonResource>(entity =>
            {
                entity.HasKey(r => r.Id);

                entity.Property(r => r.Url).IsRequired().HasMaxLength(1000);
                entity.Property(r => r.ResourceType).IsRequired().HasMaxLength(100);
                entity.Property(r => r.Title).HasMaxLength(500);
                entity.Property(r => r.Position).HasDefaultValue(0);

                entity.HasOne(r => r.Lesson)
                      .WithMany(l => l.Resources)
                      .HasForeignKey(r => r.LessonId)
                      .OnDelete(DeleteBehavior.Cascade);

                entity.HasIndex(r => r.LessonId);
            });


            // ---------------------------
            // Seed data: Catalogs, Course/Template/Diploma, ProductImages
            // ---------------------------
            // Catalogs
            builder.Entity<Catalog>().HasData(
                new Catalog
                {
                    Id = "d1f9c6d2-4b4b-4b8e-9f2a-aaaa00000001",
                    Name = "Библиотека знаний",
                    Slug = "library",
                    IsVisible = true,
                    IsLinkOnly = false
                },
                new Catalog
                {
                    Id = "d1f9c6d2-4b4b-4b8e-9f2a-aaaa00000002",
                    Name = "Курсы",
                    Slug = "courses",
                    IsVisible = true,
                    IsLinkOnly = false
                },
                new Catalog
                {
                    Id = "d1f9c6d2-4b4b-4b8e-9f2a-aaaa00000003",
                    Name = "Искуственный интелект",
                    Slug = "ai",
                    IsVisible = true,
                    IsLinkOnly = true,
                    PageName = "AI",
                    PageController = "Home"
                }
            );

            // Seed: Course 
            builder.Entity<Course>().HasData(
                new
                {
                    Id = "e1f9c6d2-5b4b-4b8e-9f2a-bbbb00000004",
                    CatalogId = "d1f9c6d2-4b4b-4b8e-9f2a-aaaa00000002",
                    Name = "Курс по ASP.NET Core",
                    Slug = "aspnet-core-web-development",
                    Price = 2499.99m,
                    Level = "Intermediate",
                    ProductType = "Course",
                    Currency = "RUB",
                    InStock = 10,
                    IsPublished = true
                },
                new
                {
                    Id = "e1f9c6d2-5b4b-4b8e-9f2a-bbbb00000005",
                    CatalogId = "d1f9c6d2-4b4b-4b8e-9f2a-aaaa00000003",
                    Name = "Введение в машинное обучение",
                    Slug = "intro-to-machine-learning",
                    Price = 2999.99m,
                    Level = "Advanced",
                    ProductType = "Course",
                    Currency = "RUB",
                    InStock = 10,
                    IsPublished = true
                }
            );

            // Seed: Template
            builder.Entity<Template>().HasData(
                new
                {
                    Id = "e1f9c6d2-5b4b-4b8e-9f2a-bbbb00000002",
                    CatalogId = "d1f9c6d2-4b4b-4b8e-9f2a-aaaa00000002",
                    Name = "Трехуровневая заготовка ASP.NET MVC",
                    Slug = "3-tier-web-template",
                    Price = 1299.00m,
                    ProductType = "Template",
                    Currency = "RUB",
                    InStock = 10,
                    IsPublished = true
                }
            );

            // Seed: Diploma
            builder.Entity<Diploma>().HasData(
                new
                {
                    Id = "e1f9c6d2-5b4b-4b8e-9f2a-bbbb00000003",
                    CatalogId = "d1f9c6d2-4b4b-4b8e-9f2a-aaaa00000003",
                    Name = "Дипломная работа",
                    Slug = "diploma-work",
                    Price = 30000m,
                    Issuer = "Code Spark Academy",
                    ProductType = "Diploma",
                    Currency = "RUB",
                    InStock = 10,
                    IsPublished = true
                }
            );

            // Seed: Tutorial
            builder.Entity<Course>().HasData(
                new
                {
                    Id = "e1f9c6d2-5b4b-4b8e-9f2a-bbbb00000006",
                    CatalogId = "d1f9c6d2-4b4b-4b8e-9f2a-aaaa00000001",
                    Name = "Руководство по Keras",
                    Slug = "keras-tutorial",
                    FullDescription = "Keras — это платформа с открытым исходным кодом глубокого обучения для Python. Она была разработана исследователем в области искусственного интеллекта из Google Франсом Шолле. В настоящее время Keras используется такими ведущими организациями, как Google, Square, Netflix, Huawei и Uber. В этом учебном руководстве рассматриваются установка Keras, основы глубокого обучения, модели Keras, слои Keras, модули Keras, а также приводятся некоторые примеры реальных приложений.\r\n",
                    Price = 0m,
                    ProductType = "Course",
                    Currency = "RUB",
                    InStock = 999,
                    IsPublished = true
                }
            );

            // ProductImage seeds 
            builder.Entity<ProductImage>().HasData(
                //new ProductImage
                //{
                //    Id = "f1f9c6d2-6b4b-4b8e-9f2a-cccc00000001",
                //    ProductId = "e1f9c6d2-5b4b-4b8e-9f2a-bbbb00000001",
                //    Name = "itcubic-main.jpg",
                //    Url = "https://cdn.example.com/courses/csharp/itcubic-main.jpg",
                //    IsMain = true,
                //    Position = 0
                //},

                //new ProductImage
                //{
                //    Id = "f1f9c6d2-6b4b-4b8e-9f2a-cccc00000002",
                //    ProductId = "e1f9c6d2-5b4b-4b8e-9f2a-bbbb00000002",
                //    Name = "codespark-main.jpg",
                //    Url = null,
                //    IsMain = true,
                //    Position = 0
                //},
                //new ProductImage
                //{
                //    Id = "f1f9c6d2-6b4b-4b8e-9f2a-cccc00000003",
                //    ProductId = "e1f9c6d2-5b4b-4b8e-9f2a-bbbb00000003",
                //    Name = "montazhka-main.jpg",
                //    Url = null,
                //    IsMain = true,
                //    Position = 0
                //},
                new ProductImage
                {
                    Id = "f1f9c6d2-6b4b-4b8e-9f2a-cccc00000006",
                    ProductId = "e1f9c6d2-5b4b-4b8e-9f2a-bbbb00000006",
                    Name = "keras-main.jpg",
                    Url = "https://avatars.mds.yandex.net/get-entity_search/2273637/428090467/S600xU",
                    IsMain = true,
                    Position = 0
                }
            );

            // ---------- Seed sample module + lesson + resource for the seeded course ----------
            var moduleId = "a1111111-1111-1111-1111-aaaaaaaaaaa1";
            var lessonId = "b2222222-2222-2222-2222-bbbbbbbbbbb2";
            var resourceId = "c3333333-3333-3333-3333-ccccccccccc3";

            // CourseId
            var seededCourseId = "e1f9c6d2-5b4b-4b8e-9f2a-bbbb00000006";

            // Модули
            builder.Entity<CourseModule>().HasData(
                new
                {
                    Id = "keras-for-beginners-main",
                    CourseId = seededCourseId,
                    Title = "Keras для начинающих",
                    Position = 1,
                }
            );

            // Уроки для модуля Keras для начинающих
            builder.Entity<Lesson>().HasData(
                new
                {
                    Id = "keras-for-beginners-module-1.01",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Введение",
                    Slug = "keras-introduction",
                    Body = "<div>\r\n    <p>«Глубокое обучение» является одним из основных направлений машинного обучения. Машинное обучение изучает\r\n        разработку\r\n        алгоритмов. Глубокое обучение становится всё более популярным в\r\n        областях науки, где работают с данными, таких как робототехника, искусственный интеллект (ИИ), распознавание\r\n        аудио и видео, а также распознавание изображений. Искусственная нейронная сеть — ядро методов глубокого\r\n        обучения.\r\n        Оно поддерживается библиотеками, такими как Theano, TensorFlow, Caffe, Mxnet и другими.\r\n        Keras — одна из самых мощных и простых в использовании библиотек Python, построенная на основе таких популярных\r\n        библиотек как TensorFlow и Theano, и предназначенная для создания моделей глубокого обучения.\r\n    </p>\r\n\r\n    <h3>Обзор Keras</h3>\r\n    <p>Keras работает на основе таких библиотек, как TensorFlow, Theano или Cognitive Toolkit (CNTK). Theano — это\r\n        библиотека Python, используется для быстрого выполнения численных вычислений. TensorFlow\r\n        — наиболее известная библиотека для символьной математики, используемая для создания нейронных сетей и моделей\r\n        глубокого обучения. TensorFlow отличается гибкостью, а его основным преимуществом является поддержка\r\n        распределённых вычислений. CNTK — это фреймворк глубокого обучения, разработанный компанией Microsoft. Для этого\r\n        используются такие библиотеки, как Python, C#, C++ или отдельные наборы инструментов для машинного обучения.\r\n        Хотя Theano и TensorFlow являются мощными библиотеками, их сложно использовать для построения\r\n        нейронных сетей напрямую.</p>\r\n\r\n    <p>Keras основан на минималистичной структуре, которая обеспечивает чистый и удобный способ создания моделей\r\n        глубокого обучения на основе TensorFlow или Theano. Он предназначен для быстрого построения\r\n        моделей глубокого обучения. Таким образом, Keras является оптимальным выбором.</p>\r\n\r\n    <h3>Особенности</h3>\r\n    <p>Keras использует различные методы оптимизации, чтобы сделать высокоуровневый API нейронных сетей простым и\r\n        эффективным. Он поддерживает следующие особенности:</p>\r\n    <ul>\r\n        <li>Единый, простой и расширяемый API.</li>\r\n        <li>Минималистичная структура — позволяет достичь результата без излишней сложности.</li>\r\n        <li>Поддержка нескольких платформ и бэкендов.</li>\r\n        <li>Удобный в использовании фреймворк, работающий как на CPU, так и на GPU.</li>\r\n        <li>Высокая масштабируемость вычислений.</li>\r\n    </ul>\r\n\r\n    <h3>Преимущества</h3>\r\n    <p>Keras — это мощный и динамичный фреймворк, который обладает следующими преимуществами:</p>\r\n    <ul>\r\n        <li>Большое сообщество пользователей и поддержка.</li>\r\n        <li>Простота тестирования.</li>\r\n        <li>Нейронные сети Keras написаны на Python, что упрощает разработку.</li>\r\n        <li>Keras поддерживает как сверточные (convolutional), так и рекуррентные (recurrent) сети.</li>\r\n        <li>Модели глубокого обучения состоят из независимых компонентов, которые можно комбинировать различными\r\n            способами.</li>\r\n    </ul>\r\n</div>",
                    Position = 0,
                    DurationMinutes = 12,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.02",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Установка",
                    Slug = "keras-installation",
                    Body = "<div>\r\n    <p>В этой главе объясняется, как установить Keras на ваш компьютер. Перед установкой рассмотрим основные требования\r\n        Keras.</p>\r\n\r\n    <h3>Необходимые компоненты</h3>\r\n    <p>Вы должны соответствовать следующим условиям:</p>\r\n    <ul>\r\n        <li>Любая операционная система (Windows, Linux или Mac)</li>\r\n        <li>Python версии 3.5 или выше</li>\r\n    </ul>\r\n\r\n    <h3>Python</h3>\r\n    <p>Keras — это библиотека нейронных сетей на основе Python, поэтому Python должен быть установлен. Если он уже\r\n        установлен, откройте терминал и введите:</p>\r\n    <pre data-editor=\"console\">python</pre>\r\n    <p>Вы должны увидедть что-то похожее на следующие:</p>\r\n    <pre data-editor=\"output\">Python 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 17:00:18)\r\n[MSC v.1900 64 bit (AMD64)] on win32\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n&gt;&gt;&gt;</pre>\r\n    <p>На данный момент актуальная версия — 3.7.2. Если Python не установлен, посетите официальный сайт <a\r\n            href=\"https://www.python.org\" target=\"_blank\">python.org</a> и скачайте и установите последнюю версию для\r\n        своей\r\n        операционной системы.</p>\r\n\r\n    <h3>Шаги установки Keras</h3>\r\n    <p>Процесс установки Keras достаточно прост. Следуйте инструкциям ниже:</p>\r\n\r\n    <h4>Шаг 1: Создание виртуального окружения</h4>\r\n    <p>Virtualenv используется для управления пакетами Python для разных проектов. Это помогает избежать конфликтов\r\n        между зависимостями. Рекомендуется использовать виртуальное окружение.</p>\r\n    <p><strong>Linux / macOS:</strong></p>\r\n    <p>Пользователям macOs и Linux необходимо перейти в корневой каталог проекта и ввести следующую команду для создания\r\n        виртуального пространства,</p>\r\n    <pre data-editor=\"console\">python3 -m venv kerasenv</pre>\r\n    <p>После выполнения указанной выше команды, в проекте будет создана директория kerasenv с папками <strong>bin,lib и\r\n            include</strong>.</p>\r\n    <p><strong>Windows:</strong></p>\r\n    <p>Пользователям Windows достаточно лишь использовать команду ниже,</p>\r\n    <pre data-editor=\"console\">py -m venv keras</pre>\r\n\r\n    <h4>Шаг 2: Активация окружения</h4>\r\n    <p>На этом этапе будут настроены исполняемые файлы python и pip в вашем системном пути (PATH). </p>\r\n    <p><strong>Linux / macOS:</strong></p>\r\n    <p>Сейчас у нас создана директория kerasenv. Перейдите в нее и выполните следующую команду,</p>\r\n    <pre data-editor=\"console\">$ cd kerasenv kerasenv $ source bin/activate</pre>\r\n\r\n    <p><strong>Windows:</strong></p>\r\n    <p>Пользователям Windows необходимо запустить внутри папки kerasenv команду ниже,</p>\r\n    <pre data-editor=\"console\">.\\env\\Scripts\\activate</pre>\r\n\r\n    <h4>Шаг 3: Установка библиотек Python</h4>\r\n    <p>Keras использует следующие библиотеки Python:</p>\r\n    <ul>\r\n        <li>Numpy</li>\r\n        <li>Pandas</li>\r\n        <li>Scikit-learn</li>\r\n        <li>Matplotlib</li>\r\n        <li>Scipy</li>\r\n        <li>Seaborn</li>\r\n    </ul>\r\n\r\n    <p>Будем надеяться, что они у вас уже установлены. Если это не так, то выполните команды ниже, чтобы установить\r\n        каждую из них.</p>\r\n    <p><strong>numpy</strong></p>\r\n    <pre data-editor=\"console\">pip install numpy</pre>\r\n    <p>Вы увидите следующий результат,</p>\r\n    <pre data-editor=\"output\">Collecting numpy\r\n   Downloading\r\nhttps://files.pythonhosted.org/packages/cf/a4/d5387a74204542a60ad1baa84cd2d3353c330e59be8cf2d47c0b11d3cde8/\r\n   numpy-3.1.1-cp36-cp36m-macosx_10_6_intel.\r\nmacosx_10_9_intel.macosx_10_9_x86_64.\r\n   macosx_10_10_intel.macosx_10_10_x86_64.whl (14.4MB)\r\n      || 14.4MB 2.8MB/s</pre>\r\n\r\n    <p><strong>pandas</strong></p>\r\n    <pre data-editor=\"console\">pip install pandas</pre>\r\n    <p>Вы увидите следующий результат,</p>\r\n    <pre data-editor=\"output\">Collecting pandas\r\n   Downloading\r\nhttps://files.pythonhosted.org/packages/cf/a4/d5387a74204542a60ad1baa84cd2d3353c330e59be8cf2d47c0b11d3cde8/\r\npandas-3.1.1-cp36-cp36m-macosx_10_6_intel.\r\nmacosx_10_9_intel.macosx_10_9_x86_64.\r\n   macosx_10_10_intel.macosx_10_10_x86_64.whl (14.4MB)\r\n      || 14.4MB 2.8MB/s</pre>\r\n\r\n    <p><strong>matplotlib</strong></p>\r\n    <p>Вы увидите следующий результат,</p>\r\n    <pre data-editor=\"output\">Collecting matplotlib\r\n   Downloading\r\nhttps://files.pythonhosted.org/packages/cf/a4/d5387a74204542a60ad1baa84cd2d3353c330e59be8cf2d47c0b11d3cde8/\r\nmatplotlib-3.1.1-cp36-cp36m-macosx_10_6_intel.\r\nmacosx_10_9_intel.macosx_10_9_x86_64.\r\n   macosx_10_10_intel.macosx_10_10_x86_64.whl (14.4MB)\r\n      || 14.4MB 2.8MB/s</pre>\r\n\r\n    <p><strong>scipy</strong></p>\r\n    <p>Вы увидите следующий результат,</p>\r\n    <pre data-editor=\"output\">Collecting scipy\r\n   Downloading\r\nhttps://files.pythonhosted.org/packages/cf/a4/d5387a74204542a60ad1baa84cd2d3353c330e59be8cf2d47c0b11d3cde8\r\n/scipy-3.1.1-cp36-cp36m-macosx_10_6_intel.\r\nmacosx_10_9_intel.macosx_10_9_x86_64.\r\n   macosx_10_10_intel.macosx_10_10_x86_64.whl (14.4MB)\r\n      || 14.4MB 2.8MB/s</pre>\r\n\r\n    <p><strong>scikit-learn</strong></p>\r\n    <p>Это библиотека машинного обучения с открытым исходным кодом. Она используется для алгоритмов классификации,\r\n        регрессии и кластеризации. Перед установкой необходимо установить следующее:</p>\r\n    <ul>\r\n        <li>Python версии 3.5 или выше</li>\r\n        <li>NumPy версии 1.11.0 или выше</li>\r\n        <li>SciPy версии 0.17.0 или выше</li>\r\n        <li>joblib 0.11 или выше</li>\r\n    </ul>\r\n    <p>Для установки scikit-learn необходима следующая команда:</p>\r\n    <pre data-editor=\"console\">pip install -U scikit-learn</pre>\r\n\r\n    <p><strong>Seaborn</strong></p>\r\n    <p>Seaborn — это замечательная библиотека, которая позволяет легко визуализировать данные. Для установки используйте\r\n        следующую команду:</p>\r\n    <pre data-editor=\"console\">pip install seaborn</pre>\r\n    <p>Вы увидите сообщение, похожее на то, что ниже</p>\r\n    <pre data-editor=\"output\">Collecting seaborn\r\n   Downloading\r\nhttps://files.pythonhosted.org/packages/a8/76/220ba4420459d9c4c9c9587c6ce607bf56c25b3d3d2de62056efe482dadc\r\n/seaborn-0.9.0-py3-none-any.whl (208kB) 100%\r\n   || 215kB 4.0MB/s\r\nRequirement already satisfied: numpy> = 1.9.3 in\r\n./lib/python3.7/site-packages (from seaborn) (1.17.0)\r\nCollecting pandas> = 0.15.2 (from seaborn)\r\n   Downloading\r\nhttps://files.pythonhosted.org/packages/39/b7/441375a152f3f9929ff8bc2915218ff1a063a59d7137ae0546db616749f9/\r\npandas-0.25.0-cp37-cp37m-macosx_10_9_x86_64.\r\nmacosx_10_10_x86_64.whl (10.1MB) 100%\r\n   || 10.1MB 1.8MB/s\r\nRequirement already satisfied: scipy>=0.14.0 in\r\n./lib/python3.7/site-packages (from seaborn) (1.3.0)\r\nCollecting matplotlib> = 1.4.3 (from seaborn)\r\n   Downloading\r\nhttps://files.pythonhosted.org/packages/c3/8b/af9e0984f\r\n5c0df06d3fab0bf396eb09cbf05f8452de4e9502b182f59c33b/\r\nmatplotlib-3.1.1-cp37-cp37m-macosx_10_6_intel.\r\nmacosx_10_9_intel.macosx_10_9_x86_64\r\n.macosx_10_10_intel.macosx_10_10_x86_64.whl (14.4MB) 100%\r\n   || 14.4MB 1.4MB/s\r\n......................................\r\n......................................\r\nSuccessfully installed cycler-0.10.0 kiwisolver-1.1.0\r\nmatplotlib-3.1.1 pandas-0.25.0 pyparsing-2.4.2\r\npython-dateutil-2.8.0 pytz-2019.2 seaborn-0.9.0</pre>\r\n\r\n    <h3>Установка Keras с помощью Python</h3>\r\n    <p>Мы установили все необходимые зависимости и теперь можно перейти к установке самого Keras. Используйте команду\r\n        ниже —</p>\r\n    <pre data-editor=\"console\">pip install keras</pre>\r\n\r\n    <h4>Выход из виртуального окружения</h4>\r\n    <p>После внесения всех необходимых изменений в проект просто выполните приведённую ниже команду, чтобы выйти из\r\n        окружения.</p>\r\n    <pre data-editor=\"console\">deactivate</pre>\r\n\r\n    <h3>Anaconda Cloud</h3>\r\n    <p>Мы считаем, что вы установили Anaconda Cloud на свой компьютер. Если Anaconda не установлена, перейдите по\r\n        официальной ссылке <a href=\"https://www.anaconda.com/download\">https://www.anaconda.com/download</a> и выберите\r\n        способ загрузки в зависимости от вашей\r\n        операционной системы.</p>\r\n\r\n    <h4>Создание новой среды conda</h4>\r\n    <p>Запустите командную строку Anaconda, чтобы открыть базовую среду Anaconda. Мы создадим новую среду conda.\r\n        Этот процесс похож на работу с virtualenv. Введите в терминале conda следующую команду:</p>\r\n    <pre data-editor=\"console\">conda create --name PythonCPU</pre>\r\n    <p>При желании вы можете создавать и устанавливать модули с использованием графического процессора (GPU). В этом\r\n        руководстве мы следуем инструкциям для центрального процессора (CPU).</p>\r\n\r\n    <h4>Активация окружения conda</h4>\r\n    <p>Для активации среды, введите команду ниже —</p>\r\n    <pre data-editor=\"console\">activate PythonCPU</pre>\r\n\r\n    <h4>Установка spyder</h4>\r\n    <p>Spyder — это интегрированная среда разработки для запуска приложений на Python. Давайте установим эту IDE в\r\n        среде conda с помощью следующей команды:</p>\r\n    <pre data-editor=\"console\">conda install spyder</pre>\r\n\r\n    <h4>Установка библиотек python</h4>\r\n    <p>Мы уже познакомились с библиотеками numpy, pandas и т. д., необходимыми для keras. Вы можете установить\r\n        все необходимые модули, используя приведённый ниже синтаксис.</p>\r\n\r\n    <p><strong>Синтаксис</strong></p>\r\n    <pre data-editor=\"console\">conda install -c anaconda &lt;название-модуля&gt;</pre>\r\n\r\n    <p>Например, вы хотите установить pandas —</p>\r\n    <pre data-editor=\"console\">conda install -c anaconda pandas</pre>\r\n    <p>Таким же образом попробуйте самостоятельно установить остальные модули.</p>\r\n\r\n    <h4>Установка Keras</h4>\r\n    <p>Теперь всё выполнено, и вы можете приступить к установке Keras следующей командой:</p>\r\n    <pre data-editor=\"console\">conda install -c anaconda keras</pre>\r\n\r\n    <h4>Запуск Spyder</h4>\r\n    <p>Наконец, запустите Spyder в терминале conda следующей командой:</p>\r\n    <pre data-editor=\"console\">spyder</pre>\r\n\r\n    <p>Чтобы проверить корректность установки, попробуйте импортировать библиотеки в Spyder. Если какая-то библиотека\r\n        отсутствует, вы получите сообщение об ошибке <strong>module not found</strong>.</p>\r\n</div>",
                    Position = 1,
                    DurationMinutes = 18,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.03",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Настройка серверной части",
                    Slug = "keras-backend-configuration",
                    Body = "<div>\r\n    <p>В этой главе подробно рассматриваются бэкенд реализации Keras для TensorFlow и Theano. Давайте разберем каждую\r\n        реализацию по отдельности.</p>\r\n\r\n    <h3>TensorFlow</h3>\r\n    <p>TensorFlow — библиотека машинного обучения с открытым исходным кодом от Google для численных вычислений. Keras —\r\n        это высокоуровневый API, построенный поверх TensorFlow или Theano.</p>\r\n    <p>Если TensorFlow не установлен, установите его командой:</p>\r\n    <pre data-editor=\"console\">pip install tensorflow</pre>\r\n    <p>После установки и при первом запуске Keras файл конфигурации обычно находится в папку .keras/keras.json</p>\r\n    <h4>keras.json</h4>\r\n    <pre data-editor=\"code\" data-ln=\"json\">{\r\n   \"image_data_format\": \"channels_last\",\r\n   \"epsilon\": 1e-07, \"floatx\": \"float32\", \"backend\": \"tensorflow\"\r\n}</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>image_data_format</b> — представляет формат изображений.</li>\r\n        <li><b>epsilon</b> — числовая константа. Используется, чтобы избежать ошибки деления на ноль.</li>\r\n        <li><b>floatx</b> — тип с плавающей запятой по умолчанию <b>float32</b>. Вы можете изменить его на\r\n            <b>float16</b> или <b>float64</b> с помощью метода <b>set_floatx()</b>\r\n        </li>\r\n    </ul>\r\n    <p>Если файл отсутствует, создайте папку и файл вручную:</p>\r\n    <pre data-editor=\"console\">> cd home\r\n> mkdir .keras\r\n> vi keras.json</pre>\r\n    <p>Помните, что необходимо указать .keras в качестве папки и добавить указанную выше конфигурацию в файл\r\n        keras.json. Мы можем выполнить некоторые операции, чтобы узнать, какие функции бэкенда есть.\r\n    </p>\r\n\r\n    <h3>Theano</h3>\r\n    <p><strong>Theano</strong> — библиотека с открытым исходным кодом для эффективных вычислений с многомерными\r\n        массивами. Установить её можно следующей командой:</p>\r\n    <pre data-editor=\"console\">pip install theano</pre>\r\n    <p>По умолчанию Keras использует TensorFlow. Чтобы переключиться на Theano, измените значение\r\n        <b>\"backend\"</b> в keras.json:\r\n    </p>\r\n    <pre data-editor=\"code\" data-ln=\"json\">{\r\n  \"image_data_format\": \"channels_last\",\r\n  \"epsilon\": 1e-07,\r\n  \"floatx\": \"float32\",\r\n  \"backend\": \"theano\"\r\n}</pre>\r\n    <p>Сохраните файл, перезагрузите терминал и запустите Keras. При успешном переключении вы увидите сообщение об\r\n        использовании Theano:</p>\r\n    <pre data-editor=\"console\">>>> import keras as k\r\nusing theano backend.</pre>\r\n</div>",
                    Position = 2,
                    DurationMinutes = 6,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.04",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Обзор возможностей глубокого обучения",
                    Slug = "keras-overview-of-deep-learning",
                    Body = "<div>\r\n    <p>Глубокое обучение — развивающаяся область машинного обучения. Оно предполагает послойный анализ входа, где\r\n        каждый слой последовательно извлекает более высокоуровневые признаки.</p>\r\n    <p>Рассмотрим простую ситуацию анализа изображения. Предположим, что входное изображение разделено на прямоугольную\r\n        сетку пикселей. Первый слой отделяет пиксели, второй — распознает границы. Следующий слой строит узлы на основе\r\n        границ. Затем следующий слой находит ветви, образованные узлами. Наконец выходной слой распознаёт целый\r\n        объект. В данном случае процесс извлечения признаков переходит от выходных данных одного слоя к входным данным\r\n        следующего слоя.</p>\r\n    <p>Такой подход позволяет обрабатывать огромные объёмы признаков, поэтому глубокое обучение — мощный инструмент.\r\n        Алгоритмы глубокого обучения особенно полезны для анализа неструктурированных данных. В этой главе рассмотрим\r\n        основы такого обучения.</p>\r\n\r\n    <h3>Искусственные нейронные сети</h3>\r\n    <p>Основной подход в глубоком обучении — использование искусственных нейронных сетей. Они основаны на модели\r\n        человеческого мозга, самого сложного органа нашего тела. Мозг человека состоит из более чем 90 миллиардов\r\n        крошечных клеток, называемых нейронами. Нейроны соединены между собой нервными волокнами, называемыми аксонами и\r\n        дендритами. Основная роль аксона — передавать информацию от одного нейрона к другому, с которым он связан.</p>\r\n    <p>Аналогично, основная роль дендритов заключается в получении информации, передаваемой аксонами других нейронов, с\r\n        которыми они связаны. Каждый нейрон обрабатывает небольшой фрагмент информации, а затем передаёт результат\r\n        другому нейрону, и этот процесс продолжается. Это основной метод, используемый человеческим мозгом для обработки\r\n        больших объёмов информации, такой как речь, зрение и т.д., и извлечения из неё полезной информации.</p>\r\n    <p>Первая искусственная нейронная сеть была предложена психологом Фрэнком Розенблаттом в 1958 году.\r\n        Они состоят из множества узлов, которые походи на нейроны. Узлы связанны между собой и организованны в различные\r\n        слои. Входной слой принимает данные, они последовательно проходят через один или несколько скрытых слоев и\r\n        попадают в выходной слой, который прогнозирует что-то полезное о входных данных. Например, входными данными\r\n        может быть изображение, а выходными — объект, идентифицированный на изображении, например, кошка.</p>\r\n    <p>Один нейрон (перцептрон) условно можно описать так —</p>\r\n    <img src=\"\" alt=\"Искусственная нейронная сеть\">\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li>Множественные входные данные вместе с весом представляют дендриты.</li>\r\n        <li><b>Сумма</b> входных данных вместе с функцией активации представляет собой нейроны. Сумма фактически\r\n            означает\r\n            вычисленное значение всех входных данных, а функция активации представляет собой функцию, которая\r\n            преобразует значение <b>суммы</b> в 0, 1 или 0 в 1.</li>\r\n        <li>Выходной сигнал представляет собой аксон, а выходной сигнал будет получен нейроном в следующем\r\n            слое.</li>\r\n    </ul>\r\n    <p>Давайте разберемся с типами нейронных сетей.</p>\r\n\r\n    <h3>Многослойный перцептрон (MLP)</h3>\r\n    <p>Многослойный перцептрон — простейшая форма искусственных нейронных сетей. Он состоит из одного входного слоя,\r\n        одного или нескольких скрытых слоёв и выходного слоя.\r\n        Каждый скрытый слой состоит из одного или нескольких нейронов, которые обрабатывают определённый аспект признака\r\n        и передают обработанную информацию следующему скрытому слою. Выходной слой получает данные из последнего\r\n        скрытого слоя и выдаёт результат.</p>\r\n    <img src=\"\" alt=\"Многослойный перцептрон\">\r\n\r\n    <h3>Свёрточная нейронная сеть (CNN)</h3>\r\n    <p>Свёрточные сети одни из самых популярных видов искусственных нейронных сетей. Они широко используются в области\r\n        распознавания изображений и видео. CNN основаны на математической концепции свёртки. Они практически аналогичны\r\n        многослойному перцептрону, за исключением того, что содержат ряд свёрточных слоёв и слоёв подвыборки (pooling\r\n        layers) перед слоем\r\n        полностью связанных скрытых нейронов. Он состоит из трёх важных слоёв —</p>\r\n    <ul>\r\n        <li><b>Свёрточный слой</b> — основной строительный блок, выполняющий вычислительные задачи на основе функции\r\n            свёртки.</li>\r\n        <li><b>Слой подвыборки</b> — располагается рядом со свёрточным слоем и используется для уменьшения объёма\r\n            входных данных путём удаления ненужной информации, что ускоряет вычисления.</li>\r\n        <li><b>Полносвязный слой</b> — располагается рядом с последовательностью свёрточных слоёв и слоёв подвыборки и\r\n            классифицирует входные данные по различным категориям.</li>\r\n    </ul>\r\n    <p>Простую сверточную нейронную сеть можно представить следующим образом —</p>\r\n    <img src=\"\" alt=\"Свёрточная нейронная сеть\">\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li>Используются две последовательные серии сверточного слоя и слоя подвыборки, которые принимают и обрабатывают\r\n            входные данные (например, изображение).</li>\r\n        <li>Один полносвязный слой используется для вывода данных (например, для классификации изображения).</li>\r\n    </ul>\r\n\r\n    <h3>Рекуррентная нейронная сеть (RNN)</h3>\r\n    <p>Рекуррентные нейронные сети полезны для устранения недостатка других моделей искусственных нейронных сетей.\r\n        Большинство ИНС не\r\n        запоминают шаги, сделанные в предыдущих ситуациях, и обучаются принимать решения на основе контекста в процессе\r\n        обучения. В то же время RNN хранит прошлую информацию, и все её решения принимаются на основе знаний, полученных\r\n        в прошлом.</p>\r\n    <p>Этот подход в основном полезен для классификации изображений. Иногда нам нужно заглянуть в будущее, чтобы\r\n        исправить прошлое. В таком случае двунаправленная RNN помогает обучаться на прошлом и предсказывать будущее.\r\n        Например, у нас есть образцы рукописного текста в нескольких входных данных. Предположим, в одном из них\r\n        возникает неоднозначность — тогда необходимо снова проверить другие входные данные, чтобы распознать правильный\r\n        контекст и принять решение, основанное на прошлом.\r\n    </p>\r\n\r\n    <h3>Работы с ANN</h3>\r\n    <p>Давайте сначала разберемся с различными фазами глубокого обучения, а затем узнаем, как Keras помогает в процессе\r\n        глубокого обучения.</p>\r\n    <h4>Сбор необходимых данных</h4>\r\n    <p>Для успешного обучения и прогнозирования результатов глубокому обучению требуется большой объём входных данных.\r\n        Поэтому сначала соберите как можно больше данных.</p>\r\n    <h4>Анализ данных</h4>\r\n    <p>Проанализируйте данные и получите хорошее понимание их структуры. Чем лучше вы понимаете данные, тем легче\r\n        выбрать подходящий алгоритм искусственной нейронной сети (ANN).</p>\r\n    <h4>Выберите алгоритм (модель)</h4>\r\n    <p>Выберите алгоритм, который лучше всего подходит для типа процесса обучения (например, классификация изображений,\r\n        обработка текста и т. д.) и доступных входных данных. В Keras алгоритм представлен моделью. Алгоритм включает\r\n        один или несколько слоёв. Каждый слой в искусственной нейронной сети (ANN) может быть представлен как слой Keras\r\n        (Keras Layer) в Keras.</p>\r\n    <ul>\r\n        <li><b>Подготовка данных</b> — обработайте, отфильтруйте и выберите только необходимую информацию из исходных\r\n            данных.\r\n        </li>\r\n        <li><b>Компиляция модели</b> — скомпилируйте алгоритм или модель, чтобы она могла использоваться для обучения и\r\n            последующего прогнозирования. На этом этапе необходимо выбрать функцию потерь (loss function) и оптимизатор\r\n            (Optimizer). Эти элементы применяются на этапе обучения для вычисления ошибки (отклонения от реального\r\n            результата) и её минимизации.</li>\r\n        <li><b>Обучение модели</b> — фактический процесс обучения выполняется на этом этапе с использованием обучающего\r\n            набора данных.</li>\r\n        <li><b>Предсказание результата для неизвестных значений</b> — выполните предсказание выходных данных для\r\n            неизвестных входных данных (отличных от обучающей и тестовой выборок).</li>\r\n        <li><b>Оценка модели</b> — оцените модель, сравнив предсказанные результаты для тестовых данных с реальными\r\n            значениями.</li>\r\n        <li><b>Заморозка, модификация или выбор нового алгоритма</b> — проверьте, успешна ли оценка модели. Если да,\r\n            сохраните алгоритм для будущих предсказаний. Если нет — измените или выберите новый алгоритм / модель и\r\n            снова выполните обучение, предсказание и оценку. Повторяйте процесс до тех пор, пока не будет найдена\r\n            наилучшая модель.</li>\r\n    </ul>\r\n    <img src=\"\" alt=\"ANN\">\r\n</div>",
                    Position = 3,
                    DurationMinutes = 16,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.05",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Глубокое обучение",
                    Slug = "keras-deep-learning",
                    Body = "<div>\r\n    <p>Keras предоставляет полноценный фреймворк для создания любых типов нейронных сетей. Keras инновационен и в то же\r\n        время очень прост в изучении. Он поддерживает как простые нейронные сети, так и очень большие и сложные модели.\r\n        В этой главе мы рассмотрим архитектуру фреймворка Keras и то, как Keras помогает в обучении глубоких нейронных\r\n        сетей.</p>\r\n\r\n    <h3>Архитектура Keras</h3>\r\n    <p>API Keras можно разделить на три основные категории:</p>\r\n    <ul>\r\n        <li><b>Model</b> (модель)</li>\r\n        <li><b>Layer</b> (слой)</li>\r\n        <li><b>Core Modules</b> (основные модули)</li>\r\n    </ul>\r\n\r\n    <p>Каждая нейронная сеть (ANN) в Keras представлена объектом <b>Model</b>. Каждая модель состоит из\r\n        набора <b>Layers</b>, соответствующих слоям сети: входным, скрытым, выходным, а также свёрточным,\r\n        слоям подвыборки и другим. Модели и слои Keras используют <b>модули</b> (activation, loss,\r\n        regularization\r\n        и т. д.), что позволяет описывать любые алгоритмы ANN (CNN, RNN и др.) просто и эффективно.</p>\r\n    <p>На следующей схеме показана взаимосвязь между моделью, уровнем и основными модулями — -</p>\r\n    <img src=\"\" alt=\"Архитектура Keras\">\r\n\r\n    <h3>Модель</h3>\r\n    <p>В Keras существует два основных типа моделей —</p>\r\n    <p><b>Последовательная модель (Sequential model)</b> — это линейная композиция слоёв Keras. Она проста,\r\n        минималистична и подходит для большинства типов нейронных сетей.</p>\r\n    <p>Простая последовательная модель выглядит следующим образом —</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Dense, Activation\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,)))\r\n</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>Строка 1</b> — импортирует модель <b>Sequential</b> из модуля <b>Keras models</b>.</li>\r\n        <li><b>Строка 2</b> — импортирует слой <b>Dense</b> и модуль <b>Activation</b>.</li>\r\n        <li>С<b>трока 4</b> — создаёт новую последовательную модель с помощью <b>Sequential API</b>.</li>\r\n        <li><b>Строка 5</b> — добавляет <b>полносвязный слой (Dense API)</b> с функцией активации <b>relu</b> (используя\r\n            модуль <b>Activation</b>).\r\n        </li>\r\n    </ul>\r\n    <p><b>Последовательная (Sequential)</b> модель предоставляет класс <b>Model</b> для создания пользовательских\r\n        моделей. Мы можем использовать концепцию наследования для создания собственной сложной модели.\r\n    </p>\r\n    <p><b>Функциональный (Functional) API</b> в основном используется для создания сложных моделей.</p>\r\n\r\n    <h3>Слои (Layers)</h3>\r\n    <p>Каждый слой в Keras соответствует реальному слою нейронной сети (входному, скрытому, выходному и т. д.).\r\n        Библиотека предоставляет множество готовых слоёв, что делает создание сложных моделей простым и\r\n        наглядным.Некоторые из важных слоёв Keras описаны ниже,</p>\r\n    <ul>\r\n        <li><b>Core Layers</b> — базовые слои.</li>\r\n        <li><b>Convolution Layers</b> — свёрточные слои.</li>\r\n        <li><b>Pooling Layers</b> — слои подвыборки.</li>\r\n        <li><b>Recurrent Layers</b> — рекуррентные слои.</li>\r\n    </ul>\r\n    <p>Пример кода нейронной сети на Keras с использованием <b>последовательной (sequential)</b> модели:</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Dense, Activation, Dropout\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(128, input_shape=(784,)))\r\nmodel.add(Activation('relu'))\r\nmodel.add(Dropout(0.5))\r\nmodel.add(Dense(64))\r\nmodel.add(Activation('relu'))\r\nmodel.add(Dropout(0.5))\r\nmodel.add(Dense(10))\r\nmodel.add(Activation('softmax'))\r\n  </pre>\r\n    <p></p>Где,:</p>\r\n    <ul>\r\n        <li><b>Строка 1</b> — импортирует модель <b>Sequential</b> из модуля <b>Keras models</b>.</li>\r\n        <li><b>Строка 2</b> — импортирует слой <b>Dense</b> и модуль <b>Activation</b>.</li>\r\n        <li><b>Строка 4 </b> — создаёт новую последовательную модель с помощью <b>Sequential API</b>.</li>\r\n        <li><b>Строка 5</b> — добавляет <b>полносвязный слой (Dense API)</b> с функцией активации <b>relu</b> (используя\r\n            модуль <b>Activation</b>).\r\n        </li>\r\n        <li><b>Строка 6</b> — добавляет слой <b>Dropout</b> (через <b>Dropout API</b>) для предотвращения переобучения.\r\n        </li>\r\n        <li><b>Строка 7</b> — добавляет ещё один <b>полносвязный слой (Dense API</b>) с функцией активации <b>relu</b>\r\n            (используя модуль\r\n            <b>Activation</b>).\r\n        </li>\r\n        <li><b>Строка 8</b> — добавляет ещё один слой <b>Dropout</b> (через <b>Dropout API</b>) для предотвращения\r\n            переобучения.</li>\r\n        <li><b>Строка 9</b> — добавляет финальный <b>полносвязный слой (Dense API)</b> с функцией активации\r\n            <b>softmax</b> (используя модуль\r\n            <b>Activation</b>).\r\n        </li>\r\n    </ul>\r\n    <p>Keras также позволяет создавать собственные кастомные слои путём наследования от класса\r\n        <b>keras.Layer</b>.\r\n    </p>\r\n\r\n    <h3>Основные модули (Core Modules)</h3>\r\n    <p>Keras также предоставляет множество встроенных функций, связанных с нейронными сетями, которые позволяют\r\n        корректно создавать модели и слои Keras. Некоторые из них —</p>\r\n    <ul>\r\n        <li><b>Модуль Activations</b> — функции активации являются важной частью искусственных нейронных сетей\r\n            (ANN). Модуль активации предоставляет множество функций активации, таких как softmax, relu и другие.</li>\r\n        <li><b>Модуль Loss</b> — модуль функции потерь предоставляет функции, такие как mean_squared_error,\r\n            mean_absolute_error, poisson и т. д.</li>\r\n        <li><b>Модуль Optimizer</b> — модуль оптимизаторов предоставляет функции оптимизации, такие как adam, sgd и\r\n            другие.</li>\r\n        <li><b>Модуль Regularizers</b> — модуль регуляризаторов предоставляет функции, такие как L1 regularizer, L2\r\n            regularizer и т. д.</li>\r\n    </ul>\r\n    <p>В следующей главе мы подробно изучим модули Keras.</p>\r\n</div>",
                    Position = 4,
                    DurationMinutes = 8,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.06",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Модули",
                    Slug = "keras-modules",
                    Body = "<div>\r\n    <p>Как мы узнали ранее, модули Keras содержат предопределённые классы, функции и переменные, которые полезны при\r\n        работе с алгоритмами глубокого обучения. В этой главе мы рассмотрим модули, предоставляемые Keras.</p>\r\n    <h3>Доступные модули</h3>\r\n    <p>Давайте сначала посмотрим на список модулей, доступных в Keras.</p>\r\n    <ul>\r\n        <li><b>Initializers</b> − Предоставляет список функций инициализации. Мы изучим это подробно в главе «Keras -\r\n            Слои» во время фазы создания модели машинного обучения.</li>\r\n        <li><b>Regularizers</b> − Предоставляет список функций регуляризации. Мы изучим это подробно в главе «Keras -\r\n            Слои».\r\n        </li>\r\n        <li><b>Constraints</b> − Предоставляет список функций ограничений. Мы изучим это подробно в главе «Keras -\r\n            Слои».\r\n        </li>\r\n        <li><b>Activations</b> − Предоставляет список функций активации. Мы изучим это подробно в главе «Keras -\r\n            Слои».\r\n        </li>\r\n        <li><b>Losses</b> − Предоставляет список функций потерь. Мы изучим это подробно в главе, посвещенной обучению\r\n            модели.</li>\r\n        <li><b>Metrics</b> − Предоставляет список функций метрик. Мы изучим это подробно в главе, посвещенной\r\n            обучению модели.</li>\r\n        <li><b>Optimizers</b> − Предоставляет список функций оптимизаторов. Мы изучим это подробно в главе, посвещенной\r\n            обучению модели.</li>\r\n        <li><b>Callback</b> − Предоставляет список функций обратного вызова. Их можно использовать во время обучения для\r\n            вывода промежуточных данных и для остановки обучения (например, <b>EarlyStopping</b>) по условию.</li>\r\n        <li><b>Text processing</b> − Предоставляет функции для преобразования текста в NumPy-массив, пригодный для\r\n            машинного обучения (этап подготовки данных).</li>\r\n        <li><b>Image processing</b> − Предоставляет функции для преобразования изображений в NumPy-массив, пригодный для\r\n            машинного обучения (этап подготовки данных).</li>\r\n        <li><b>Sequence processing</b> − Предоставляет функции для генерации временных данных из входного набора (этап\r\n            подготовки данных).</li>\r\n        <li><b>Backend</b> − Предоставляет функции бэкенд-библиотек, таких как TensorFlow и Theano.</li>\r\n        <li><b>Utilities</b> − Предоставляет множество полезных утилит для глубокого обучения.</li>\r\n    </ul>\r\n    <p>В этой главе мы рассмотрим <b>backend</b> модуль и модель <b>утилит (Utilities)</b>.</p>\r\n\r\n    <h3>Модуль backend</h3>\r\n    <p>Модуль <b>backend</b> используется для выполнения внутренних операций Keras. По умолчанию Keras работает поверх\r\n        бэкенда TensorFlow. При желании вы можете переключиться на другие бэкенды, такие как Theano или CNTK.\r\n        Конфигурация бэкенда по умолчанию задаётся в корневом каталоге в файле .keras/keras.json.\r\n    </p>\r\n    <p>Модуль <b>backend</b> можно импортировать с помощью приведённого ниже кода</p>\r\n    <pre data-editor=\"console\">>>> from keras import backend as k</pre>\r\n    <p>Если мы используем бэкенд по умолчанию — TensorFlow, то следующая функция возвращает информацию, основанную\r\n        на TensorFlow, как указано ниже.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> k.backend()\r\n'tensorflow'\r\n>>> k.epsilon()\r\n1e-07\r\n>>> k.image_data_format()\r\n'channels_last'\r\n>>> k.floatx()\r\n'float32'</pre>\r\n    <p>Давайте рассмотрим некоторые важные серверные функции, используемые для анализа данных —</p>\r\n\r\n    <h4>get_uid()</h4>\r\n    <p>Это идентификатор для графа по умолчанию. Определяется следующим образом —</p>\r\n    <pre data-editor=\"console\">\r\n>>> k.get_uid(prefix='')\r\n1\r\n>>> k.get_uid(prefix='')\r\n2</pre>\r\n\r\n    <h4>reset_uids()</h4>\r\n    <p>Используется для сброса значения идентификатора (uid).</p>\r\n    <pre data-editor=\"console\">\r\n        >>> k.reset_uids()\r\n    </pre>\r\n    <p>Теперь снова выполните команду get_uid(). Значение будет сброшено и снова станет равным 1.</p>\r\n    <p>Некоторые полезные функции:</p>\r\n    <pre data-editor=\"console\">\r\n        >>> k.get_uid(prefix='')\r\n        1</pre>\r\n\r\n    <h4>placeholder</h4>\r\n    <p>Используется для создания тензора-заполнителя. Ниже показан простой заполнитель для хранения трёхмерной фигуры.\r\n    </p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> data = k.placeholder(shape = (1,3,3))\r\n>>> data\r\n&lt;tf.Tensor 'Placeholder_9:0' shape=(1, 3, 3) dtype=float32&gt;\r\n\r\nIf you use int_shape(), it will show the shape.\r\n\r\n>>> k.int_shape(data) (1, 3, 3)</pre>\r\n\r\n    <h4>dot</h4>\r\n    <p>Используется для умножения двух тензоров.\r\n        Пусть <b>a</b> и <b>b</b> — два тензора, а <b>c</b> — результат их умножения.\r\n        Предположим, что форма <b>a</b> — (4,2), а форма <b>b</b> — (2,3). Тогда:</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> a = k.placeholder(shape = (4,2))\r\n>>> b = k.placeholder(shape = (2,3))\r\n>>> c = k.dot(a,b)\r\n>>> c\r\n&lt;tf.Tensor 'MatMul_3:0' shape=(4, 3) dtype=float32&gt;\r\n    >>></pre>\r\n\r\n    <h4>ones</h4>\r\n    <p>Используется для инициализации всех значений единицами.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> res = k.ones(shape = (2,2))\r\n\r\n#print the value\r\n\r\n>>> k.eval(res)\r\narray([[1., 1.], [1., 1.]], dtype = float32)</pre>\r\n\r\n    <h4>batch_dot</h4>\r\n    <p>Используется для выполнения произведения (умножения) двух данных пакетами (batch-wise).\r\n        Размерность входных данных должна быть <b>2 или выше</b>.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> a_batch = k.ones(shape = (2,3))\r\n>>> b_batch = k.ones(shape = (3,2))\r\n>>> c_batch = k.batch_dot(a_batch,b_batch)\r\n>>> c_batch\r\n&lt;tf.Tensor 'ExpandDims:0' shape=(2, 1) dtype=float32&gt;</pre>\r\n\r\n    <h4>variable</h4>\r\n    <p>Используется для инициализации переменной.\r\n        Рассмотрим пример простой операции транспонирования над переменной:</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> data = k.variable([[10,20,30,40],[50,60,70,80]])\r\n#variable initialized here\r\n>>> result = k.transpose(data)\r\n>>> print(result)\r\nTensor(\"transpose_6:0\", shape = (4, 2), dtype = float32)\r\n>>> print(k.eval(result))\r\n[[10. 50.]\r\n[20. 60.]\r\n[30. 70.]\r\n[40. 80.]]</pre>\r\n    <p>Если вы хотите получить тот же результат с помощью NumPy:</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> data = np.array([[10,20,30,40],[50,60,70,80]])\r\n\r\n>>> print(np.transpose(data))\r\n[[10 50]\r\n[20 60]\r\n[30 70]\r\n[40 80]]\r\n\r\n>>> res = k.variable(value = data)\r\n>>> print(res)\r\n&lt;tf.Variable 'Variable_7:0' shape=(2, 4) dtype=float32_ref>&gt;</pre>\r\n\r\n    <h4>is_sparse(tensor)</h4>\r\n    <p>Используется для проверки, является ли тензор <b>разреженным</b> (sparse) или нет.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n >>> a = k.placeholder((2, 2), sparse=True)\r\n\r\n>>> print(a) SparseTensor(indices =\r\nTensor(\"Placeholder_8:0\",\r\nshape = (?, 2), dtype = int64),\r\nvalues = Tensor(\"Placeholder_7:0\", shape = (?,),\r\ndtype = float32), dense_shape = Tensor(\"Const:0\", shape = (2,), dtype = int64))\r\n\r\n>>> print(k.is_sparse(a)) True</pre>\r\n\r\n    <h4>to_dense()</h4>\r\n    <p>Используется для преобразования <b>разреженного</b> (sparse) тензора в <b>плотный</b> (dense).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> b = k.to_dense(a)\r\n>>> print(b) Tensor(\"SparseToDense:0\", shape = (2, 2), dtype = float32)\r\n>>> print(k.is_sparse(b)) False</pre>\r\n\r\n    <h4>random_uniform_variable</h4>\r\n    <p>Используется для инициализации переменных с использованием <b>равномерного распределения (uniform\r\n            distribution)</b>.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nk.random_uniform_variable(shape, mean, scale)</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>shape</b> — кортеж, задающий количество строк и столбцов.</li>\r\n        <li><b>mean</b> — среднее значение распределения.</li>\r\n        <li><b>scale</b> — стандартное отклонение распределения.</li>\r\n    </ul>\r\n    <p>Пример использования:</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> a = k.random_uniform_variable(shape = (2, 3), low=0, high = 1)\r\n>>> b = k. random_uniform_variable(shape = (3,2), low = 0, high = 1)\r\n>>> c = k.dot(a, b)\r\n>>> k.int_shape(c)\r\n(2, 2)</pre>\r\n\r\n    <h3>utils module</h3>\r\n    <p>Модуль <b>utils</b> предоставляет различные полезные функции для глубокого обучения.\r\n        Некоторые из методов, предоставляемых этим модулем:</p>\r\n\r\n    <h4>HDF5Matrix</h4>\r\n    <p>Используется для представления входных данных в формате <b>HDF5</b>.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.utils import HDF5Matrix data = HDF5Matrix('data.hdf5', 'data')</pre>\r\n\r\n    <h4>to_categorical</h4>\r\n    <p>Используется для преобразования векторных меток классов в бинарную матрицу классов.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> from keras.utils import to_categorical\r\n>>> labels = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n>>> to_categorical(labels)\r\narray([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\r\n[0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],\r\n[0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\r\n[0., 0., 0., 1., 0., 0., 0., 0., 0., 0.],\r\n[0., 0., 0., 0., 1., 0., 0., 0., 0., 0.],\r\n[0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],\r\n[0., 0., 0., 0., 0., 0., 1., 0., 0., 0.],\r\n[0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],\r\n[0., 0., 0., 0., 0., 0., 0., 0., 1., 0.],\r\n[0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]], dtype = float32)\r\n>>> from keras.utils import normalize\r\n>>> normalize([1, 2, 3, 4, 5])\r\narray([[0.13483997, 0.26967994, 0.40451992, 0.53935989, 0.67419986]])</pre>\r\n\r\n    <h4>normalize</h4>\r\n    <p>Используется для нормализации данных (приведения значений к одному масштабу).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> from keras.utils import normalize\r\n>>> normalize([1, 2, 3, 4, 5])\r\narray([[0.13483997, 0.26967994, 0.40451992, 0.53935989, 0.67419986]])</pre>\r\n\r\n    <h4>print_summary</h4>\r\n    <p>Используется для вывода сводки модели (структура, параметры, количество слоёв и т. д.).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.utils import print_summary\r\nprint_summary(model)</pre>\r\n\r\n    <h4>plot_model</h4>\r\n    <p>Используется для создания графического представления модели в формате DOT и сохранения его в файл.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.utils import plot_model\r\nplot_model(model,to_file = 'image.png')</pre>\r\n    <p>Эта функция создаёт изображение, помогающее визуально понять архитектуру и работу модели.</p>\r\n</div>",
                    Position = 5,
                    DurationMinutes = 14,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.07",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Слои",
                    Slug = "keras-layers",
                    Body = "<div>\r\n    <p>Как мы уже узнали ранее, слои Keras являются основным строительным блоком моделей Keras. Каждый слой получает\r\n        входные данные, выполняет над ними некоторые вычисления и, в итоге, выдаёт преобразованную информацию. Выход\r\n        одного слоя поступает на вход следующему. В этой главе мы подробно изучим все аспекты, связанные со слоями.\r\n    </p>\r\n\r\n    <h3>Введение</h3>\r\n    <p>Слой Keras требует указания <b>формы входных данных (input_shape)</b>, чтобы понимать их структуру,\r\n        <b>инициализатора</b> — для задания начальных весов каждого входа, и функции активации — для преобразования\r\n        выходных данных, делая их нелинейными.\r\n    </p>\r\n    <p>Кроме того, ограничения (constraints) задают диапазон значений, в котором могут генерироваться веса входных\r\n        данных, а регуляризатор (regularizer) оптимизирует слой (и всю модель), динамически накладывая штрафы на веса во\r\n        время процесса оптимизации.\r\n    </p>\r\n    <p>В итоге, для создания полноценного слоя Keras необходимо минимум следующие параметры —</p>\r\n    <ul>\r\n        <li>Форма входных данных</li>\r\n        <li>Количество нейронов / единиц в слое</li>\r\n        <li>Инициализаторы</li>\r\n        <li>Регуляризаторы</li>\r\n        <li>Ограничения</li>\r\n        <li>Функции активации</li>\r\n    </ul>\r\n    <p>Давайте разберёмся с основной концепцией в следующей главе. Прежде чем перейти к теории, создадим простой слой\r\n        Keras с использованием Sequential API, чтобы понять, как работает модель и слои Keras.\r\n    </p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\nfrom keras import regularizers\r\nfrom keras import constraints\r\n\r\nmodel = Sequential()\r\n\r\nmodel.add(Dense(32, input_shape=(16,), kernel_initializer = 'he_uniform',\r\n    kernel_regularizer = None, kernel_constraint = 'MaxNorm', activation = 'relu'))\r\nmodel.add(Dense(16, activation = 'relu'))\r\nmodel.add(Dense(8))</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>Строки 1–5</b> импортируют необходимые модули.</li>\r\n        <li><b>Строка 7</b> создаёт новую модель с использованием Sequential API.</li>\r\n        <li>\r\n            <b>Строка 9</b> создаёт новый слой <b>Dense</b> и добавляет его в модель. <b>Dense</b> — это базовый\r\n            слой (входного уровня), предоставляемый Keras. Он принимает обязательный параметр — количество нейронов (в\r\n            данном случае 32). Если слой является первым в модели, необходимо также указать <b>форму входных данных\r\n                (input_shape = (16,)</b>). В противном случае — на вход слоя поступает результат предыдущего слоя. Все\r\n            остальные параметры являются необязательными.\r\n            <ul>\r\n                <li><b>Первый параметр</b> — количество единиц (нейронов).</li>\r\n                <li><b>input_shape</b> — форма входных данных.</li>\r\n                <li><b>kernel_initializer</b> — используемый инициализатор. Функция <b>he_uniform</b> задаётся как\r\n                    значение.\r\n                </li>\r\n                <li><b>kernel_regularizer</b> — используемый <b>регуляризатор</b>. В качестве значения установлено None.\r\n                </li>\r\n                <li><b>kernel_constraint</b> — ограничение для весов. В качестве значения задана функция <b>MaxNorm</b>.\r\n                </li>\r\n                <li><b>activation</b> — функция активации. В качестве значения задана функция relu.</li>\r\n            </ul>\r\n        </li>\r\n        <li><b>Строка 10</b> создаёт второй слой Dense с 16 нейронами и функцией активации relu.</li>\r\n        <li><b>Строка 11</b> создаёт финальный слой Dense с 8 нейронами.</li>\r\n    </ul>\r\n\r\n    <h3>Основная концепция слоев</h3>\r\n    <p>Давайте разберём основную идею слоя, а также то, как Keras поддерживает каждое из этих понятий.</p>\r\n\r\n    <h4>Форма входных данных (Input shape)</h4>\r\n    <p>В машинном обучении все типы входных данных, такие как текст, изображения или видео, сначала преобразуются в\r\n        массив чисел, а затем передаются в алгоритм. Входные данные могут представлять собой одномерный,\r\n        двумерный (матрицу) или многомерный массив. Мы можем задать размерность данных с помощью параметра <b>shape</b>,\r\n        который представляет собой кортеж целых чисел. Например, <b>(4, 2)</b> обозначает матрицу с четырьмя строками и\r\n        двумя столбцами.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> import numpy as np\r\n>>> shape = (4, 2)\r\n>>> input = np.zeros(shape)\r\n>>> print(input)\r\n[\r\n[0. 0.]\r\n[0. 0.]\r\n[0. 0.]\r\n[0. 0.]\r\n]\r\n>>></pre>\r\n    <p>Аналогично, <b>(3, 4, 2)</b> обозначает трёхмерную матрицу, состоящую из трёх наборов матриц размером 4×2 (четыре\r\n        строки и два столбца).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> import numpy as np\r\n>>> shape = (3, 4, 2)\r\n>>> input = np.zeros(shape)\r\n>>> print(input)\r\n[\r\n[[0. 0.] [0. 0.] [0. 0.] [0. 0.]]\r\n[[0. 0.] [0. 0.] [0. 0.] [0. 0.]]\r\n[[0. 0.] [0. 0.] [0. 0.] [0. 0.]]\r\n]\r\n>>></pre>\r\n    <p>Чтобы создать первый слой модели (входной слой модели), необходимо указать форму входных данных.</p>\r\n\r\n    <h3>Иницализаторы (Initializers)</h3>\r\n    <p>В машинном обучении каждому входному значению назначается вес. Модуль <b>Initializers</b> предоставляет различные\r\n        функции для обозначения этих начальных весов. Некоторые функции инициализаторов Keras приведены ниже −</p>\r\n\r\n    <h4>Zeros</h4>\r\n    <p>Генерирует значение <b>0</b> для всех входных данных.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.Zeros()\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_initializer = my_init))</pre>\r\n    <p>Где, <b>kernel_initializer</b> это инициализатор для ядра модели.</p>\r\n\r\n    <h4>Ones</h4>\r\n    <p>Генерирует значение <b>1</b> для всех входных данных.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.Ones()\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_initializer = my_init))</pre>\r\n\r\n    <h4>Constant</h4>\r\n    <p>Генерирует константное значение, указанное пользователем (например, <b>5</b>), для всех входных данных.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.Constant(value = 0) model.add(\r\nDense(512, activation = 'relu', input_shape = (784,), = my_init)\r\n)</pre>\r\n    <p>Где, <b>value</b> — это константное значение.</p>\r\n\r\n    <h4>RandomNormal</h4>\r\n    <p>Генерирует значения, используя нормальное распределение входных данных.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.RandomNormal(mean=0.0,\r\nstddev = 0.05, seed = None)\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_initializer = my_init))</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>mean</b> — среднее значение случайных чисел, которые будут сгенерированы</li>\r\n        <li><b>stddev</b> — стандартное отклонение случайных чисел</li>\r\n        <li><b>seed</b> — значение для генерации случайного числа.</li>\r\n    </ul>\r\n\r\n    <h4>RandomUniform</h4>\r\n    <p>Генерирует значения, используя равномерное распределение входных данных.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.RandomUniform(minval = -0.05, maxval = 0.05, seed = None)\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_initializer = my_init))</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>minval</b> — нижняя граница случайных значений</li>\r\n        <li><b>maxval</b> — верхняя граница случайных значений</li>\r\n    </ul>\r\n\r\n    <h4>TruncatedNormal</h4>\r\n    <p>Генерирует значения, используя усечённое нормальное распределение входных данных.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.TruncatedNormal(mean = 0.0, stddev = 0.05, seed = None\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_initializer = my_init))</pre>\r\n\r\n    <h4>VarianceScaling</h4>\r\n    <p>Генерирует значения на основе формы входных и выходных данных слоя, а также заданного коэффициента\r\n        масштабирования.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.VarianceScaling(\r\nscale = 1.0, mode = 'fan_in', distribution = 'normal', seed = None)\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nskernel_initializer = my_init))</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>scale</b> — коэффициент масштабирования</li>\r\n        <li><b>mode</b> — представляет любое из <b>fan_in</b>, <b>fan_out</b> или <b>fan_avg</b> значений</li>\r\n        <li><b>distribution</b> — тип распределения (<b>normal</b> или <b>uniform</b>).</li>\r\n    </ul>\r\n\r\n    <h4>VarianceScaling</h4>\r\n    <p>Для нормального распределения функция вычисляет значение стандартного отклонения (<b>stddev</b>) по следующей\r\n        формуле, а затем генерирует веса на основе этого распределения,</p>\r\n    <pre data-editor=\"output\">stddev = sqrt(scale / n)</pre>\r\n    <p>где <b>n</b> это,</p>\r\n    <ul>\r\n        <li>количество входных нейронов, если mode = fan_in</li>\r\n        <li>количество выходных нейронов, если mode = fan_out</li>\r\n        <li>среднее значение между входными и выходными нейронами, если mode = fan_avg</li>\r\n    </ul>\r\n    <p>Аналогично, для равномерного распределения функция вычисляет предел по формуле, а затем генерирует веса с\r\n        использованием равномерного распределения,</p>\r\n    <pre data-editor=\"output\">limit = sqrt(3 * scale / n)</pre>\r\n\r\n    <h4>lecun_normal</h4>\r\n    <p>Генерирует значения, используя нормальное распределение входных данных.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.RandomUniform(minval = -0.05, maxval = 0.05, seed = None)\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_initializer = my_init))</pre>\r\n    <p>Значение стандартного отклонения вычисляется по следующей формуле, после чего применяется нормальное\r\n        распределение</p>\r\n    <pre data-editor=\"output\">stddev = sqrt(1 / fan_in)</pre>\r\n    <p>Где, <b>fan_in</b> — количество входных нейронов.</p>\r\n\r\n    <h4>lecun_uniform</h4>\r\n    <p>Генерирует значения, используя равномерное распределение входных данных.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.lecun_uniform(seed = None)\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_initializer = my_init))</pre>\r\n    <p>Предел вычисляется по следующей формуле, после чего применяется равномерное распределение</p>\r\n    <pre data-editor=\"output\">limit = sqrt(3 / fan_in)</pre>\r\n    <p>где,</p>\r\n    <ul>\r\n        <li><b>fan_in</b> — количество входных нейронов</li>\r\n        <li><b>fan_out</b> — количество выходных нейронов</li>\r\n    </ul>\r\n\r\n    <h4>glorot_normal</h4>\r\n    <p>Генерирует значения, используя нормальное распределение Ксавье Глорот (Xavier Glorot) для входных данных.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.glorot_normal(seed=None) model.add(\r\nDense(512, activation = 'relu', input_shape = (784,), kernel_initializer = my_init)\r\n)</pre>\r\n    <p>Стандартное отклонение (<b>stddev</b>) вычисляется по формуле, а затем применяется нормальное распределение</p>\r\n    <pre data-editor=\"output\">stddev = sqrt(2 / (fan_in + fan_out))</pre>\r\n    <p>где,</p>\r\n    <ul>\r\n        <li><b>fan_in</b> — количество входных нейронов</li>\r\n        <li><b>fan_out</b> — количество выходных нейронов</li>\r\n    </ul>\r\n\r\n    <h4>glorot_uniform</h4>\r\n    <p>Генерирует значения, используя равномерное распределение Ксавье Глорот (Xavier Glorot) для входных данных.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.glorot_uniform(seed = None)\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_initializer = my_init))</pre>\r\n    <p><b>Предел</b> вычисляется по формуле, а затем применяется равномерное распределение.</p>\r\n    <pre data-editor=\"output\">limit = sqrt(6 / (fan_in + fan_out))</pre>\r\n    <p>где,</p>\r\n    <ul>\r\n        <li><b>fan_in</b> — количество входных нейронов</li>\r\n        <li><b>fan_out</b> — количество выходных нейронов</li>\r\n    </ul>\r\n\r\n    <h4>he_normal</h4>\r\n    <p>Генерирует значения, используя нормальное распределение Хе (He) для входных данных.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.RandomUniform(minval = -0.05, maxval = 0.05, seed = None)\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_initializer = my_init))</pre>\r\n    <p>Предел</b> вычисляется по формуле, а заетм применяется нормальное распределение.</p>\r\n    <pre data-editor=\"output\">stddev = sqrt(2 / fan_in)</pre>\r\n    <p>где, <b>fan_in</b> — количество входных нейронов.</p>\r\n\r\n    <h4>he_uniform</h4>\r\n    <p>Генерирует значения, используя равномерное распределение Хе (He) для входных данных.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.he_normal(seed = None)\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_initializer = my_init))</pre>\r\n    <p>Предел</b> вычисляется по формуле, а затем применяется равномерное распределение.</p>\r\n    <pre data-editor=\"output\">limit = sqrt(6 / fan_in)</pre>\r\n    <p>где, <b>fan_in</b> — количество входных нейронов.</p>\r\n\r\n    <h4>Orthogonal</h4>\r\n    <p>Генерирует случайную ортогональную матрицу.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.Orthogonal(gain = 1.0, seed = None)\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_initializer = my_init))</pre>\r\n    <p>где <b>gain</b> — это коэффициент масштабирования (множитель) матрицы.</p>\r\n\r\n    <h4>Identity</h4>\r\n    <p>Генерирует единичную матрицу.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.Identity(gain = 1.0) model.add(\r\nDense(512, activation = 'relu', input_shape = (784,), kernel_initializer = my_init)\r\n)</pre>\r\n\r\n    <h3>Ограничения</h3>\r\n    <p>В машинном обучении ограничения накладываются на веса (параметры) во время процесса оптимизации,\r\n        чтобы регулировать диапазон их значений. Модуль constraints в Keras предоставляет несколько функций для задания\r\n        таких ограничений.</p>\r\n\r\n    <h4>NonNeg</h4>\r\n    <p>Ограничивает веса так, чтобы они были неотрицательными.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import initializers\r\n\r\nmy_init = initializers.Identity(gain = 1.0) model.add(\r\nDense(512, activation = 'relu', input_shape = (784,),\r\nkernel_initializer = my_init)\r\n)</pre>\r\n    <p>где <b>kernel_constraint</b> указывает, какое ограничение применяется к слоям.</p>\r\n\r\n    <h4>UnitNorm</h4>\r\n    <p>Ограничивает веса так, чтобы они имели единичную норму (т.е. длина вектора весов = 1).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import constraints\r\n\r\nmy_constrain = constraints.UnitNorm(axis = 0)\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_constraint = my_constrain))</pre>\r\n    <p>где <b>axis</b> определяет ось, вдоль которой нормализуются веса.</p>\r\n\r\n    <h4>MaxNorm</h4>\r\n    <p>Ограничивает веса так, чтобы их норма не превышала заданного значения.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import constraints\r\n\r\nmy_constrain = constraints.MaxNorm(max_value = 2, axis = 0)\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_constraint = my_constrain))</pre>\r\n    <p>где,</p>\r\n    <ul>\r\n        <li><b>max_value</b> — максимальное допустимое значение нормы весов</li>\r\n        <li><b>axis</b> — ось, по которой применяется ограничение. Например, при форме <b>(2, 3, 4)</b> axis=0 — первая\r\n            размерность, axis=1 — вторая, axis=2 — третья</li>\r\n    </ul>\r\n\r\n    <h4>MinMaxNorm</h4>\r\n    <p>Ограничивает веса так, чтобы их норма находилась между заданными минимальным и максимальным значениями.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import constraints\r\n\r\nmy_constrain = constraints.MinMaxNorm(min_value = 0.0, max_value = 1.0, rate = 1.0, axis = 0)\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_constraint = my_constrain))</pre>\r\n    <p>где,</p>\r\n    <ul>\r\n        <li><b>min_value</b> — минимально допустимое значение нормы</li>\r\n        <li><b>max_value</b> — максимально допустимое значение нормы</li>\r\n        <li><b>rate</b> — скорость, с которой применяется ограничение весов</li>\r\n        <li><b>axis</b> — ось, вдоль которой выполняется нормализация</li>\r\n    </ul>\r\n\r\n    <h3>Регуляризаторы</h3>\r\n    <p>В машинном обучении регуляризация используется на этапе оптимизации для предотвращения переобучения.\r\n        Регуляризаторы накладывают штраф на веса слоя во время обучения модели. В Keras эти штрафы задаются на\r\n        уровне каждого слоя.</p>\r\n\r\n    <h4>L1 Regularizer</h4>\r\n    <p>Применяет L1-регуляризацию, то есть добавляет штраф, пропорциональный абсолютным значениям весов.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import regularizers\r\n\r\nmy_regularizer = regularizers.l1(0.)\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_regularizer = my_regularizer))</pre>\r\n    <p>где <b>kernel_regularizer</b> определяет, какой тип регуляризации применяется к весам слоя.</p>\r\n\r\n    <h4>L2 Regularizer</h4>\r\n    <p>Применяет L2-регуляризацию, добавляя штраф, пропорциональный квадрату значений весов.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import regularizers\r\n\r\nmy_regularizer = regularizers.l2(0.)\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_regularizer = my_regularizer))</pre>\r\n\r\n    <h4>L1 and L2 Regularizer</h4>\r\n    <p>Комбинирует оба типа регуляризации — L1 и L2, одновременно учитывая как абсолютные значения, так и квадраты\r\n        весов.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\nfrom keras import regularizers\r\n\r\nmy_regularizer = regularizers.l2(0.)\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,),\r\nkernel_regularizer = my_regularizer))</pre>\r\n\r\n    <h3>Функции активации</h3>\r\n    <p>В машинном обучении функция активации — это специальная функция, которая определяет, активируется ли конкретный\r\n        нейрон или нет. По сути, функция активации выполняет нелинейное преобразование входных данных, что позволяет\r\n        нейронам обучаться более эффективно. Выход нейрона зависит именно от функции активации.</p>\r\n    <p>Если вспомнить концепцию одиночного перцептрона, то его выход — это результат функции активации, которая получает\r\n        сумму всех входов, умноженных на соответствующие веса, плюс общее смещение, если оно есть.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">result = Activation(SUMOF(input * weight) + bias)</pre>\r\n    <p>Таким образом, функция активации играет важную роль в успешном обучении модели. Модуль activations в Keras\r\n        предоставляет множество таких функций. Ниже приведены основные из них.</p>\r\n\r\n    <h4>linear</h4>\r\n    <p>Применяет линейную функцию. Ничего не делает (т.е. возвращает вход как есть).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'linear', input_shape = (784,)))</pre>\r\n    <p>Здесь <b>activation</b> указывает функцию активации слоя. Можно просто указать имя функции — слой сам применит\r\n        соответствующую активацию.</p>\r\n\r\n    <h4>elu</h4>\r\n    <p>Применяет Exponential Linear Unit (экспоненциальную линейную единицу).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'selu', input_shape = (784,)))</pre>\r\n\r\n    <h4>selu</h4>\r\n    <p>Применяет Scaled Exponential Linear Unit (масштабированную экспоненциальную линейную единицу).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'selu', input_shape = (784,)))</pre>\r\n\r\n    <h4>relu</h4>\r\n    <p>Применяет Rectified Linear Unit (выровненную линейную функцию).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,)))</pre>\r\n\r\n    <h4>softmax</h4>\r\n    <p>Применяет Softmax-функцию (часто используется для многоклассовой классификации).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'softmax', input_shape = (784,)))</pre>\r\n\r\n    <h4>softplus</h4>\r\n    <p>Применяет Softplus-функцию (плавная альтернатива ReLU).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'softplus', input_shape = (784,)))</pre>\r\n\r\n    <h4>softsign</h4>\r\n    <p>Применяет Softsign-функцию (ограничивает значения в диапазоне от -1 до 1).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'softsign', input_shape = (784,)))</pre>\r\n\r\n    <h4>tanh</h4>\r\n    <p>Применяет функцию гиперболического тангенса.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'tanh', input_shape = (784,)))</pre>\r\n\r\n    <h4>sigmoid</h4>\r\n    <p>Применяет сигмоидную (логистическую) функцию (возвращает значения в диапазоне [0, 1]).</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'sigmoid', input_shape = (784,)))</pre>\r\n\r\n    <h4>hard_sigmoid</h4>\r\n    <p>Применяет упрощённую (линейно приближенную) сигмоидную функцию.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'hard_sigmoid', input_shape = (784,)))</pre>\r\n\r\n    <h4>exponential</h4>\r\n    <p>Применяет экспоненциальную функцию.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Activation, Dense\r\n\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'exponential', input_shape = (784,)))</pre>\r\n</div>",
                    Position = 6,
                    DurationMinutes = 16,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.08",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Настроиваемые слои",
                    Slug = "keras-custom-layers",
                    Body = "<div>\r\n    <p>Keras позволяет создавать собственные пользовательские слои. После создания новый слой можно использовать в любой\r\n        модели без ограничений. В этом разделе мы узнаем, как создать собственный слой.</p>\r\n    <p>Keras предоставляет базовый класс слоя — <b>Layer</b>, который можно наследовать, чтобы создать свой собственный\r\n        слой.\r\n        Создадим простой слой, который будет генерировать веса на основе нормального распределения, а затем выполнять\r\n        базовое вычисление — нахождение суммы произведений входных данных и соответствующих им весов во время обучения.\r\n    </p>\r\n\r\n    <h3>Шаг 1. Импорт необходимых модулей</h3>\r\n    <p>Сначала импортируем нужные модули −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras import backend as K\r\nfrom keras.layers import Layer</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>backend</b> используется для доступа к функции <b>dot</b></li>\r\n        <li><b>Layer</b> — это базовый класс, который мы будем наследовать для создания собственного слоя.</li>\r\n    </ul>\r\n\r\n    <h3>Шаг 2: Определение класса слоя</h3>\r\n    <p>Создадим новый класс <b>MyCustomLayer</b>, унаследовав его от класса <b>Layer</b> —</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nclass MyCustomLayer(Layer):\r\n...</pre>\r\n\r\n    <h3>Шаг 3: Инициализация класса слоя</h3>\r\n    <p>Инициализируем наш новый класс следующим образом −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\ndef __init__(self, output_dim, **kwargs):\r\n    self.output_dim = output_dim\r\n    super(MyCustomLayer, self).__init__(**kwargs)\r\n    </pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>Строка 2</b> — устанавливает размерность выходных данных (output_dim).</li>\r\n        <li><b>Строка 3</b> — вызывает функцию инициализации базового (родительского) класса Layer.</li>\r\n    </ul>\r\n\r\n    <h3>Шаг 4: Реализация метода build</h3>\r\n    <p>Метод build — это основной метод, предназначенный для корректного построения слоя. Он выполняет все операции,\r\n        связанные с внутренней работой слоя. После выполнения пользовательской логики обязательно нужно вызвать базовую\r\n        функцию build. Наш собственный метод build выглядит так −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\ndef build(self, input_shape):\r\nself.kernel = self.add_weight(name = 'kernel',\r\nshape = (input_shape[1], self.output_dim),\r\ninitializer = 'normal', trainable = True)\r\nsuper(MyCustomLayer, self).build(input_shape)</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>Строка 1</b> — определяет метод <b>build</b> с одним аргументом <b>input_shape</b>. Он содержит форму\r\n            входных данных.</li>\r\n        <li><b>Строки 2–5</b> — создают веса (weights) в соответствии с формой входных данных и сохраняют их в kernel.\r\n            Это пользовательская логика слоя. Здесь веса инициализируются с помощью нормального распределения.</li>\r\n        <li><b>Строка 6</b> — вызывает базовый метод <b>build</b> из класса <b>Layer</b>.</li>\r\n    </ul>\r\n\r\n    <h3>Шаг 5: Реализация метода call</h3>\r\n    <p>Метод <b>call</b> выполняет фактическую работу слоя во время обучения.</p>\r\n    <p>Наш пользовательский метод call выглядит так</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\ndef call(self, input_data):\r\nreturn K.dot(input_data, self.kernel)</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>Строка 1</b> — определяет метод <b>call</b> с аргументом <b>input_data</b>, который представляет входные\r\n            данные слоя.</li>\r\n        <li><b>Строка 2</b> — возвращает результат скалярного произведения между входными данными <b>input_data</b> и\r\n            весами слоя <b>self.kernel</b>.</li>\r\n    </ul>\r\n\r\n    <h3>Шаг 6: Реализация метода compute_output_shape</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\ndef compute_output_shape(self, input_shape): return (input_shape[0], selfoutput_dim)</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>Строка 1</b> — определяет метод <b>compute_output_shape</b> с аргументом <b>input_shape</b>.</li>\r\n        <li><b>Строка 2</b> вычисляет форму выходных данных на основе формы входных данных и размерности выхода,\r\n            заданной при инициализации слоя.</li>\r\n    </ul>\r\n    <p>После реализации методов <b>build</b>, <b>call</b> и <b>compute_output_shape</b> наш собственный слой готов.\r\n        Полный код пользовательского слоя выглядит так</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras import backend as K from keras.layers import Layer\r\nclass MyCustomLayer(Layer):\r\ndef __init__(self, output_dim, **kwargs):\r\nself.output_dim = output_dim\r\nsuper(MyCustomLayer, self).__init__(**kwargs)\r\ndef build(self, input_shape): self.kernel =\r\nself.add_weight(name = 'kernel',\r\nshape = (input_shape[1], self.output_dim),\r\ninitializer = 'normal', trainable = True)\r\nsuper(MyCustomLayer, self).build(input_shape) #\r\nBe sure to call this at the end\r\ndef call(self, input_data): return K.dot(input_data, self.kernel)\r\ndef compute_output_shape(self, input_shape): return (input_shape[0], selfoutput_dim)</pre>\r\n\r\n    <h3>Использование нашего пользовательского слоя</h3>\r\n    <p>Создадим простую модель, используя наш собственный слой, как показано ниже −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Dense\r\n\r\nmodel = Sequential()\r\nmodel.add(MyCustomLayer(32, input_shape = (16,)))\r\nmodel.add(Dense(8, activation = 'softmax')) model.summary()</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li>Наш слой <b>MyCustomLayer</b> добавляется в модель с 32 нейронами и входной формой <b>(16,)</b>.</li>\r\n    </ul>\r\n    <p>После запуска программы будет выведено краткое описание модели −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nModel: \"sequential_1\"\r\n_________________________________________________________________\r\nLayer (type)                 Output Shape              Param\r\n=================================================================\r\nmy_custom_layer_1 (MyCustomL (None, 32)                512\r\n_________________________________________________________________\r\ndense_1 (Dense)              (None, 8)                 264\r\n=================================================================\r\nTotal params: 776\r\nTrainable params: 776\r\nNon-trainable params: 0\r\n_________________________________________________________________</pre>\r\n    <p>Где,</p>\r\n    <ul>\r\n        <li><b>Output Shape</b> — форма выходных данных каждого слоя</li>\r\n        <li><b>Param</b> — количество обучаемых параметров (весов)</li>\r\n        <li><b>Total params</b> — общее число параметров</li>\r\n        <li><b>Trainable params</b> — параметры, которые будут обновляться при обучении</li>\r\n        <li><b>Non-trainable params</b> — параметры, которые не участвуют в обучении</li>\r\n    </ul>\r\n</div>",
                    Position = 7,
                    DurationMinutes = 13,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.09",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Модели",
                    Slug = "keras-models",
                    Body = "<div>\r\n    <p>Как мы узнали ранее, модель Keras представляет собой саму нейронную сеть. Keras предоставляет два способа\r\n        создания моделей, Sequential API — простой и удобный способ создания последовательных моделей, Functional API —\r\n        более гибкий и продвинутый подход для построения сложных архитектур. В этом разделе мы узнаем, как создавать\r\n        модели с помощью Sequential API и Functional API.</p>\r\n\r\n    <h3>Sequential</h3>\r\n    <p>Основная идея <b>Sequential API</b> заключается в простом расположении слоёв Keras в последовательном порядке,\r\n        поэтому он и называется Sequential (последовательным) API. Большинство искусственных нейронных сетей (ANN) также\r\n        имеют последовательную структуру, где данные проходят от одного слоя к другому в заданном порядке, пока не\r\n        достигнут выходного слоя.</p>\r\n    <p>\r\n        Модель ANN можно создать простым вызовом функции Sequential() следующим образом −\r\n    </p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nmodel = Sequential()</pre>\r\n\r\n    <h4>Добавление слоев</h4>\r\n    <p>Чтобы добавить слой, достаточно создать его с помощью <b>Keras Layer API</b> и передать в функцию <b>add()</b>,\r\n        как показано ниже −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\n\r\nmodel = Sequential()\r\ninput_layer = Dense(32, input_shape=(8,))\r\nmodel.add(input_layer)\r\nhidden_layer = Dense(64, activation='relu')\r\nmodel.add(hidden_layer)\r\noutput_layer = Dense(8)\r\nmodel.add(output_layer)</pre>\r\n    <p>Здесь мы создали один входной слой, один скрытый слой и один выходной слой.</p>\r\n\r\n    <h4>Доступ к модели</h4>\r\n    <p>Keras предоставляет несколько методов для получения информации о модели, таких как слои, входные и выходные\r\n        данные. Ниже перечислены основные из них −</p>\r\n    <ul>\r\n        <li><b>model.layers</b> − возвращает все слои модели в виде списка.</li>\r\n    </ul>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> layers = model.layers\r\n>>> layers\r\n[\r\n&lt;keras.layers.core.Dense object at 0x000002C8C888B8D0&gt;,\r\n&lt;keras.layers.core.Dense object at 0x000002C8C888B7B8&gt;\r\n&lt;keras.layers.core.Dense object at 0x 000002C8C888B898&gt;\r\n]</pre>\r\n    <ul>\r\n        <li><b>model.inputs</b> − возвращает все входные тензоры модели в виде списка.</li>\r\n    </ul>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> inputs = model.inputs\r\n>>> inputs\r\n[&lt;tf.Tensor 'dense_13_input:0' shape=(?, 8) dtype=float32&gt;]</pre>\r\n    <ul>\r\n        <li><b>model.outputs</b> − возвращает все выходные тензоры модели в виде списка.</li>\r\n    </ul>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> outputs = model.outputs\r\n>>> outputs\r\n&lt;tf.Tensor 'dense_15/BiasAdd:0' shape=(?, 8) dtype=float32&gt;]</pre>\r\n    <ul>\r\n        <li><b>model.get_weights</b> − возвращает все веса модели в виде NumPy массивов.</li>\r\n        <li><b>model.set_weights(weight_numpy_array)</b> − позволяет установить веса модели, передав их в виде NumPy\r\n            массива.</li>\r\n    </ul>\r\n    <h3>Сериализация модели</h3>\r\n    <p>Keras позволяет сериализовать модель (сохранить её структуру) в виде объекта, JSON или YAML, а затем восстановить\r\n        её.</p>\r\n    <ul>\r\n        <li>Возвращает модель в виде объектной конфигурации.</li>\r\n    </ul>\r\n    <pre data-editor=\"code\" data-ln=\"python\">config = model.get_config()</pre>\r\n    <ul>\r\n        <li>Принимает объект конфигурации и создаёт новую модель на его основе.</li>\r\n    </ul>\r\n    <pre data-editor=\"code\" data-ln=\"python\">new_model = Sequential.from_config(config)</pre>\r\n    <ul>\r\n        <li><b>to_json</b> — возвращает модель в виде JSON-строки.</li>\r\n    </ul>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> json_string = model.to_json()\r\n>>> json_string '&#123;\"class_name\": \"Sequential\", \"config\":\r\n&#123;\"name\": \"sequential_10\", \"layers\":\r\n[&#123;\"class_name\": \"Dense\", \"config\":\r\n&#123;\"name\": \"dense_13\", \"trainable\": true, \"batch_input_shape\":\r\n[null, 8], \"dtype\": \"float32\", \"units\": 32, \"activation\": \"linear\",\r\n\"use_bias\": true, \"kernel_initializer\":\r\n&#123;\"class_name\": \"VarianceScaling\", \"config\":\r\n&#123;\"scale\": 1.0, \"mode\": \"fan_avg\", \"distribution\": \"uniform\", \"seed\": null&#125;&#125;,\r\n\"bias_initializer\": &#123;\"class_name\": \"Zeros\", \"config\": &#123;&#125;&#125;, \"kernel_regularizer\": null,\r\n\"bias_regularizer\": null,\r\n\"activity_regularizer\": null, \"kernel_constraint\": null, \"bias_constraint\": null&#125;&#125;,\r\n&#123;\"class_name\": \"Dense\", \"config\": &#123;\"name\": \"dense_14\", \"trainable\": true,\r\n\"dtype\": \"float32\", \"units\": 64, \"activation\": \"relu\", \"use_bias\": true,\r\n\"kernel_initializer\": &#123;\"class_name\": \"VarianceScaling\", \"config\":\r\n&#123;\"scale\": 1.0, \"mode\": \"fan_avg\", \"distribution\": \"uniform\", \"seed\": null&#125;&#125;,\r\n\"bias_initializer\": &#123;\"class_name\": \"Zeros\",\r\n\"config\": &#123;&#125;&#125;, \"kernel_regularizer\": null, \"bias_regularizer\": null,\r\n\"activity_regularizer\": null, \"kernel_constraint\": null, \"bias_constraint\": null&#125;&#125;,\r\n&#123;\"class_name\": \"Dense\", \"config\": &#123;\"name\": \"dense_15\", \"trainable\": true,\r\n\"dtype\": \"float32\", \"units\": 8, \"activation\": \"linear\", \"use_bias\": true,\r\n\"kernel_initializer\": &#123;\"class_name\": \"VarianceScaling\", \"config\":\r\n&#123;\"scale\": 1.0, \"mode\": \"fan_avg\", \"distribution\": \"uniform\", \"seed\": null&#125;&#125;,\r\n\"bias_initializer\": &#123;\"class_name\": \"Zeros\", \"config\": &#123;&#125;&#125;,\r\n\"kernel_regularizer\": null, \"bias_regularizer\": null, \"activity_regularizer\":\r\nnull, \"kernel_constraint\": null, \"bias_constraint\":\r\nnull&#125;&#125;&#125;, \"keras_version\": \"2.2.5\", \"backend\": \"tensorflow\"&#125;'\r\n>>></pre>\r\n    <ul>\r\n        <li><b>model_from_json()</b> — создаёт модель из JSON-представления.</li>\r\n    </ul>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import model_from_json\r\nnew_model = model_from_json(json_string)</pre>\r\n    <ul>\r\n        <li><b>to_yaml()</b> — создаёт модель из JSON-представления.</li>\r\n    </ul>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> yaml_string = model.to_yaml()\r\n>>> yaml_string 'backend: tensorflow\\nclass_name:\r\nSequential\\nconfig:\\n layers:\\n - class_name: Dense\\n config:\\n\r\nactivation: linear\\n activity_regular izer: null\\n batch_input_shape:\r\n!!python/tuple\\n - null\\n - 8\\n bias_constraint: null\\n bias_initializer:\\n\r\nclass_name : Zeros\\n config: {}\\n bias_regularizer: null\\n dtype:\r\nfloat32\\n kernel_constraint: null\\n\r\nkernel_initializer:\\n cla ss_name: VarianceScaling\\n config:\\n\r\ndistribution: uniform\\n mode: fan_avg\\n\r\nscale: 1.0\\n seed: null\\n kernel_regularizer: null\\n name: dense_13\\n\r\ntrainable: true\\n units: 32\\n\r\nuse_bias: true\\n - class_name: Dense\\n config:\\n activation: relu\\n activity_regularizer: null\\n\r\nbias_constraint: null\\n bias_initializer:\\n class_name: Zeros\\n\r\nconfig : {}\\n bias_regularizer: null\\n dtype: float32\\n\r\nkernel_constraint: null\\n kernel_initializer:\\n class_name: VarianceScalin g\\n\r\nconfig:\\n distribution: uniform\\n mode: fan_avg\\n scale: 1.0\\n\r\nseed: null\\n kernel_regularizer: nu ll\\n name: dense_14\\n trainable: true\\n\r\nunits: 64\\n use_bias: true\\n - class_name: Dense\\n config:\\n\r\nactivation: linear\\n activity_regularizer: null\\n\r\nbias_constraint: null\\n bias_initializer:\\n\r\nclass_name: Zeros\\n config: {}\\n bias_regu larizer: null\\n\r\ndtype: float32\\n kernel_constraint: null\\n\r\nkernel_initializer:\\n class_name: VarianceScaling\\n config:\\n\r\ndistribution: uniform\\n mode: fan_avg\\n\r\nscale: 1.0\\n seed: null\\n kernel_regularizer: null\\n name: dense _15\\n\r\ntrainable: true\\n units: 8\\n\r\nuse_bias: true\\n name: sequential_10\\nkeras_version: 2.2.5\\n'\r\n>>></pre>\r\n    <ul>\r\n        <li><b>model_from_yaml()</b> — создаёт модель из YAML-представления.</li>\r\n    </ul>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import model_from_yaml\r\nnew_model = model_from_yaml(yaml_string)</pre>\r\n\r\n    <h3>Сводка модели</h3>\r\n    <p>Понимание модели — очень важный этап для правильного использования её в процессе обучения и предсказания. Keras\r\n        предоставляет простой метод <b>summary</b>, который выводит полную информацию о модели и её слоях.</p>\r\n    <p>Сводка модели, созданной в предыдущем разделе, выглядит следующим образом −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n>>> model.summary() Model: \"sequential_10\"\r\n_________________________________________________________________\r\nLayer (type) Output Shape Param\r\n#================================================================\r\ndense_13 (Dense) (None, 32) 288\r\n_________________________________________________________________\r\ndense_14 (Dense) (None, 64) 2112\r\n_________________________________________________________________\r\ndense_15 (Dense) (None, 8) 520\r\n=================================================================\r\nTotal params: 2,920\r\nTrainable params: 2,920\r\nNon-trainable params: 0\r\n_________________________________________________________________\r\n>>></pre>\r\n\r\n    <h3>Обучение и предсказание модели</h3>\r\n    <p>Модель предоставляет функции для процесса обучения, оценки и предсказания. Они следующие −</p>\r\n    <ul>\r\n        <li><b>compile</b> − настраивает процесс обучения модели;</li>\r\n        <li><b>fit</b> − обучает модель на тренировочных данных;</li>\r\n        <li><b>evaluate</b> − оценивает модель на тестовых данных;</li>\r\n        <li><b>predict</b> − делает предсказания для новых входных данных.</li>\r\n    </ul>\r\n\r\n    <h3>Функциональный API (Functional API)</h3>\r\n    <p>Sequential API используется для создания моделей слой за слоем. Functional API — альтернативный подход для\r\n        создания\r\n        более сложных моделей. С функциональной моделью вы можете задавать несколько входов и/или выходов и повторно\r\n        использовать слои. Сначала создаётся входной объект модели и затем слои соединяются, чтобы задать вход и выход\r\n        модели. В этом разделе кратко описывается Functional модель.</p>\r\n\r\n    <h4>Создание модели</h4>\r\n    <p>Импортируйте входной слой с помощью следующего модуля −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\"> >>> from keras.layers import Input</pre>\r\n    <p>Теперь создайте входной слой, указав форму входных данных для модели, используя следующий код −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\"> >>> data = Input(shape=(2,3)) </pre>\r\n    <p>Определите слой для входа, используя следующий модуль −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\"> >>> from keras.layers import Dense</pre>\r\n    <p>Добавьте слой Dense для входа, используя следующую строку кода −</p>\r\n    <pre data-editor=\"code\"\r\n        data-ln=\"python\"> >>> layer = Dense(2)(data) >>> print(layer) Tensor(\"dense_1/add:0\", shape =(?, 2, 2), dtype = float32)</pre>\r\n    <p>Определите модель, используя следующий модуль −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\"> from keras.models import Model </pre>\r\n    <p>Создайте модель функционально, указав одновременно вход и выход слоя −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\"> >>> model = Model(inputs = data, outputs = layer)</pre>\r\n    <p>Полный код для создания простой модели показан ниже −</p>\r\n    <pre data-editor=\"code\"\r\n        data-ln=\"python\"> from keras.layers import Input from keras.models import Model from keras.layers import Dense data = Input(shape=(2,3)) layer = Dense(2)(data) model = Model(inputs=data, outputs=layer) model.summary()</pre>\r\n    <pre\r\n        data-editor=\"output\"> _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_2 (InputLayer) (None, 2, 3) 0 _________________________________________________________________ dense_2 (Dense) (None, 2, 2) 8 ================================================================= Total params: 8 Trainable params: 8 Non-trainable params: 0 _________________________________________________________________ </pre>\r\n</div>",
                    Position = 8,
                    DurationMinutes = 12,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.10",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Компиляция модели",
                    Slug = "keras-model-compilation",
                    Body = "<div>\r\n    <p>Ранее мы изучали основы создания модели с использованием Sequential и Functional API. В этой главе\r\n        рассматривается,\r\n        как компилировать модель. Компиляция — это заключительный шаг при создании модели. После компиляции можно\r\n        переходить\r\n        к этапу обучения. Ниже — несколько понятий, которые полезно знать перед разбором процесса компиляции.</p>\r\n\r\n    <h3>Loss (Функция потерь)</h3>\r\n\r\n    <p>В машинном обучении функция потерь (loss function) используется для оценки ошибки или отклонения в процессе\r\n        обучения.\r\n        Keras требует указания функции потерь в процессе компиляции модели.</p>\r\n\r\n    <p>В модуле <b>losses</b> Keras присутствует множество функций потерь, в том числе:</p>\r\n    <ul>\r\n        <li>mean_squared_error</li>\r\n        <li>mean_absolute_error</li>\r\n        <li>mean_absolute_percentage_error</li>\r\n        <li>mean_squared_logarithmic_error</li>\r\n        <li>squared_hinge</li>\r\n        <li>hinge</li>\r\n        <li>categorical_hinge</li>\r\n        <li>logcosh</li>\r\n        <li>huber_loss</li>\r\n        <li>categorical_crossentropy</li>\r\n        <li>sparse_categorical_crossentropy</li>\r\n        <li>binary_crossentropy</li>\r\n        <li>kullback_leibler_divergence</li>\r\n        <li>poisson</li>\r\n        <li>cosine_proximity</li>\r\n        <li>is_categorical_crossentropy</li>\r\n    </ul>\r\n\r\n    <p>Все перечисленные функции потерь принимают два аргумента:</p>\r\n    <ul>\r\n        <li><b>y_true</b> — истинные метки в виде тензоров;</li>\r\n        <li><b>y_pred</b> — предсказания модели той же формы, что и y_true.</li>\r\n    </ul>\r\n\r\n    <p>Перед использованием функций потерь импортируйте модуль:</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">from keras import losses</pre>\r\n\r\n    <h3>Optimizer (Оптимизатор)</h3>\r\n\r\n    <p>В машинном обучении оптимизация — это процесс настройки весов модели путём сравнения предсказаний и функции\r\n        потерь.\r\n        Keras предоставляет модуль <b>optimizers</b> с множеством реализаций оптимизаторов:</p>\r\n\r\n    <ul>\r\n        <li><b>SGD</b> — стохастический градиентный спуск:\r\n            <pre data-editor=\"code\"\r\n                data-ln=\"python\">keras.optimizers.SGD(learning_rate = 0.01, momentum = 0.0, nesterov = False)</pre>\r\n        </li>\r\n\r\n        <li><b>RMSprop</b>:\r\n            <pre data-editor=\"code\" data-ln=\"python\">keras.optimizers.RMSprop(learning_rate = 0.001, rho = 0.9)</pre>\r\n        </li>\r\n\r\n        <li><b>Adagrad</b>:\r\n            <pre data-editor=\"code\" data-ln=\"python\">keras.optimizers.Adagrad(learning_rate = 0.01)</pre>\r\n        </li>\r\n\r\n        <li><b>Adadelta</b>:\r\n            <pre data-editor=\"code\" data-ln=\"python\">keras.optimizers.Adadelta(learning_rate = 1.0, rho = 0.95)</pre>\r\n        </li>\r\n\r\n        <li><b>Adam</b>:\r\n            <pre data-editor=\"code\" data-ln=\"python\">\r\nkeras.optimizers.Adam(\r\n   learning_rate = 0.001, beta_1 = 0.9, beta_2 = 0.999, amsgrad = False\r\n)</pre>\r\n        </li>\r\n\r\n        <li><b>Adamax</b>:\r\n            <pre data-editor=\"code\"\r\n                data-ln=\"python\">keras.optimizers.Adamax(learning_rate = 0.002, beta_1 = 0.9, beta_2 = 0.999)</pre>\r\n        </li>\r\n\r\n        <li><b>Nadam</b> (Nesterov Adam):\r\n            <pre data-editor=\"code\"\r\n                data-ln=\"python\">keras.optimizers.Nadam(learning_rate = 0.002, beta_1 = 0.9, beta_2 = 0.999)</pre>\r\n        </li>\r\n    </ul>\r\n\r\n    <p>Перед использованием оптимизаторов импортируйте модуль:</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">from keras import optimizers</pre>\r\n\r\n    <h3>Metrics (Метрики)</h3>\r\n\r\n    <p>Метрики используются для оценки качества модели (например, точности). В отличие от функции потерь, метрики\r\n        не участвуют в процессе оптимизации (не влияют на обновление весов), но полезны для мониторинга. Модуль\r\n        <b>metrics</b> Keras содержит, в частности:\r\n    </p>\r\n    <ul>\r\n        <li>accuracy</li>\r\n        <li>binary_accuracy</li>\r\n        <li>categorical_accuracy</li>\r\n        <li>sparse_categorical_accuracy</li>\r\n        <li>top_k_categorical_accuracy</li>\r\n        <li>sparse_top_k_categorical_accuracy</li>\r\n        <li>cosine_proximity</li>\r\n        <li>clone_metric</li>\r\n    </ul>\r\n\r\n    <p>Как и функции потерь, метрики обычно принимают <b>y_true</b> и <b>y_pred</b>.</p>\r\n\r\n    <p>Импорт:</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">from keras import metrics</pre>\r\n\r\n    <h3>Компиляция модели (compile)</h3>\r\n\r\n    <p>Keras предоставляет метод <b>compile()</b> для компиляции модели. Подпись метода и его параметры (по умолчанию)\r\n        выглядят так:</p>\r\n\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\ncompile(\r\n   optimizer,\r\n   loss = None,\r\n   metrics = None,\r\n   loss_weights = None,\r\n   sample_weight_mode = None,\r\n   weighted_metrics = None,\r\n   target_tensors = None\r\n)</pre>\r\n\r\n    <p>Ключевые аргументы:</p>\r\n    <ul>\r\n        <li>функция потерь (loss)</li>\r\n        <li>оптимизатор (optimizer)</li>\r\n        <li>метрики (metrics)</li>\r\n    </ul>\r\n\r\n    <p>Пример компиляции:</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras import losses\r\nfrom keras import optimizers\r\nfrom keras import metrics\r\n\r\nmodel.compile(loss = 'mean_squared_error',\r\n   optimizer = 'sgd', metrics = [metrics.categorical_accuracy])</pre>\r\n\r\n    <p>Здесь:\r\n    <ul>\r\n        <li>loss = 'mean_squared_error' — функция потерь mean squared error;</li>\r\n        <li>optimizer = 'sgd' — стохастический градиентный спуск;</li>\r\n        <li>metrics = [metrics.categorical_accuracy] — в качестве метрики используется categorical_accuracy.</li>\r\n    </ul>\r\n    </p>\r\n\r\n    <h3>Обучение модели (Model Training)</h3>\r\n\r\n    <p>Модели обучаются на NumPy-массивах с помощью метода <b>fit()</b>. Основная цель fit — обучить модель на\r\n        тренировочных\r\n        данных и при необходимости собрать историю качества для визуализации. Общий синтаксис:</p>\r\n\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel.fit(X, y, epochs = , batch_size = )</pre>\r\n\r\n    <p>Параметры:</p>\r\n    <ul>\r\n        <li><b>X, y</b> — входные данные и метки (обычно кортеж или массивы);</li>\r\n        <li><b>epochs</b> — количество проходов по всему набору данных (эпох);</li>\r\n        <li><b>batch_size</b> — размер мини-батча при обновлении градиента.</li>\r\n    </ul>\r\n\r\n    <p>Ниже — пример с использованием случайных данных NumPy.</p>\r\n\r\n    <h4>Создание данных</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nimport numpy as np\r\n\r\nx_train = np.random.random((100,4,8))\r\ny_train = np.random.random((100,10))\r\n\r\nx_val = np.random.random((100,4,8))\r\ny_val = np.random.random((100,10))\r\n  </pre>\r\n\r\n    <h4>Создание модели</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.models import Sequential\r\nmodel = Sequential()</pre>\r\n\r\n    <h4>Добавление слоёв</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.layers import LSTM, Dense\r\n\r\n# добавляем последовательность векторов размерности 16\r\nmodel.add(LSTM(16, return_sequences = True))\r\nmodel.add(Dense(10, activation = 'softmax'))</pre>\r\n\r\n    <h4>Компиляция модели</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel.compile(\r\n   loss = 'categorical_crossentropy', optimizer = 'sgd', metrics = ['accuracy']\r\n)</pre>\r\n\r\n    <h4>Применение fit()</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel.fit(x_train, y_train, batch_size = 32, epochs = 5, validation_data = (x_val, y_val))</pre>\r\n\r\n    <h4>Создание многослойного перцептрона (MLP / ANN)</h4>\r\n\r\n    <p>Мы научились создавать, компилировать и обучать модели Keras. Теперь применим знания и построим простой MLP\r\n        (полносвязную\r\n        нейронную сеть).</p>\r\n\r\n    <h4>Модуль datasets</h4>\r\n    <p>Перед созданием модели нужно выбрать задачу, собрать данные и привести их к виду NumPy-массивов. Сбор данных —\r\n        один из\r\n        самых трудных этапов ML. Keras предоставляет модуль <b>datasets</b>, который позволяет скачивать\r\n        распространённые датасеты\r\n        с сервера, предварительно обрабатывать их и возвращать в виде train/test наборов.</p>\r\n\r\n    <p>В модуле доступны, например:</p>\r\n    <ul>\r\n        <li>CIFAR10 — классификация маленьких изображений</li>\r\n        <li>CIFAR100 — классификация маленьких изображений</li>\r\n        <li>IMDB — анализ тональности обзоров</li>\r\n        <li>Reuters — классификация новостных лент</li>\r\n        <li>MNIST — база рукописных цифр</li>\r\n        <li>Fashion-MNIST — база изображений одежды</li>\r\n        <li>Boston housing — регрессия цен на жильё</li>\r\n    </ul>\r\n\r\n    <p>Для примера используем MNIST (60,000 изображений 28×28 (grayscale) для тренировки и 10,000 для теста; 10\r\n        классов).</p>\r\n\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.datasets import mnist\r\n\r\n(x_train, y_train), (x_test, y_test) = mnist.load_data()</pre>\r\n\r\n    <p>Здесь:\r\n    <ul>\r\n        <li>первая строка импортирует MNIST из модуля datasets;</li>\r\n        <li>вторая строка вызывает load_data(), которая скачивает данные и возвращает два кортежа: (x_train, y_train) и\r\n            (x_test, y_test).\r\n            x_train имеет форму (число_образцов, 28, 28), y_train — вектор меток формы (число_образцов,).</li>\r\n    </ul>\r\n    </p>\r\n\r\n    <h3>Создание модели (MLP)</h3>\r\n    <p>Давайте выберем простую многослойную перцептронную сеть (MLP), как показано ниже, и попробуем создать модель с\r\n        помощью Keras.</p>\r\n    <img src=\"https://github.com/Inseliq/img.code-spark/blob/main/create_models.svg?raw=true\" alt=\"Создание модели\">\r\n    <ul>\r\n        <li><b>Входной слой:</b> состоит из 784 значений (28 x 28 = 784).</li>\r\n        <li><b>Первый скрытый слой — Dense:</b> 512 нейронов, функция активации <b>relu</b>.</li>\r\n        <li><b>Второй скрытый слой — Dropout:</b> значение <b>0.2</b>.</li>\r\n        <li><b>Третий скрытый слой — Dense:</b> 512 нейронов, функция активации <b>relu</b>.</li>\r\n        <li><b>Четвёртый скрытый слой — Dropout:</b> значение <b>0.2</b>.</li>\r\n        <li><b>Пятый (выходной) слой:</b> 10 нейронов, функция активации <b>softmax</b>.</li>\r\n        <li><b>Функция потерь:</b> <b>categorical_crossentropy</b>.</li>\r\n        <li><b>Оптимизатор:</b> <b>RMSprop()</b>.</li>\r\n        <li><b>Метрика:</b> <b>accuracy</b>.</li>\r\n        <li><b>Размер батча:</b> <b>128</b>.</li>\r\n        <li><b>Эпохи:</b> <b>20</b>.</li>\r\n    </ul>\r\n\r\n    <h4>Шаг 1 — импорт модулей</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nimport keras\r\nfrom keras.datasets import mnist\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Dense, Dropout\r\nfrom keras.optimizers import RMSprop\r\nimport numpy as np</pre>\r\n\r\n    <h4>Шаг 2 — загрузка данных</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n(x_train, y_train), (x_test, y_test) = mnist.load_data()</pre>\r\n\r\n    <h4>Шаг 3 — обработка данных</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nx_train = x_train.reshape(60000, 784)\r\nx_test = x_test.reshape(10000, 784)\r\nx_train = x_train.astype('float32')\r\nx_test = x_test.astype('float32')\r\nx_train /= 255\r\nx_test /= 255\r\n\r\ny_train = keras.utils.to_categorical(y_train, 10)\r\ny_test = keras.utils.to_categorical(y_test, 10)</pre>\r\n\r\n    <p>Пояснения:</p>\r\n    <ul>\r\n        <li><b>reshape</b> — преобразует вход из (28, 28) в (784, );</li>\r\n        <li><b>to_categorical</b> — превращает вектор меток в бинарную матрицу (one-hot encoding).</li>\r\n    </ul>\r\n\r\n    <h4>Шаг 4 — создание модели</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation = 'relu', input_shape = (784,)))\r\nmodel.add(Dropout(0.2))\r\nmodel.add(Dense(512, activation = 'relu'))\r\nmodel.add(Dropout(0.2))\r\nmodel.add(Dense(10, activation = 'softmax'))</pre>\r\n\r\n    <h4>Шаг 5 — компиляция модели</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel.compile(loss = 'categorical_crossentropy',\r\n   optimizer = RMSprop(),\r\n   metrics = ['accuracy'])</pre>\r\n\r\n    <h4>Шаг 6 — обучение модели</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nhistory = model.fit(\r\n   x_train, y_train,\r\n   batch_size = 128,\r\n   epochs = 20,\r\n   verbose = 1,\r\n   validation_data = (x_test, y_test)\r\n)</pre>\r\n\r\n    <h3>Итоговые замечания</h3>\r\n\r\n    <p>Мы создали модель, загрузили и подготовили данные, а затем обучили модель. Далее необходимо оценить модель и\r\n        делать\r\n        предсказания на незнакомых данных — это рассматривается в следующей главе.</p>\r\n\r\n    <p>Ниже приведён полный сводный пример кода (тот же, что использовался выше):</p>\r\n\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nimport keras\r\nfrom keras.datasets import mnist\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Dense, Dropout\r\nfrom keras.optimizers import RMSprop\r\nimport numpy as np\r\n\r\n(x_train, y_train), (x_test, y_test) = mnist.load_data()\r\nx_train = x_train.reshape(60000, 784)\r\nx_test = x_test.reshape(10000, 784)\r\nx_train = x_train.astype('float32')\r\nx_test = x_test.astype('float32')\r\nx_train /= 255\r\nx_test /= 255\r\n\r\ny_train = keras.utils.to_categorical(y_train, 10)\r\ny_test = keras.utils.to_categorical(y_test, 10)\r\nmodel = Sequential()\r\nmodel.add(Dense(512, activation='relu', input_shape = (784,)))\r\nmodel.add(Dropout(0.2))\r\nmodel.add(Dense(512, activation = 'relu'))\r\nmodel.add(Dropout(0.2))\r\nmodel.add(Dense(10, activation = 'softmax'))\r\nmodel.compile(loss = 'categorical_crossentropy',\r\n   optimizer = RMSprop(),\r\n   metrics = ['accuracy'])\r\n\r\nhistory = model.fit(x_train, y_train,\r\n   batch_size = 128, epochs = 20, verbose = 1, validation_data = (x_test, y_test))</pre>\r\n\r\n    <p>Ожидаемый вывод при выполнении (пример логов обучения):</p>\r\n\r\n    <pre data-editor=\"output\">\r\nTrain on 60000 samples, validate on 10000 samples\r\nEpoch 1/20\r\n60000/60000 [==============================] - 7s 118us/step - loss: 0.2453 - acc: 0.9236 - val_loss: 0.1004 - val_acc: 0.9675\r\nEpoch 2/20\r\n60000/60000 [==============================] - 7s 110us/step - loss: 0.1023 - acc: 0.9693 - val_loss: 0.0797 - val_acc: 0.9761\r\n...\r\nEpoch 20/20\r\n60000/60000 [==============================] - 7s 112us/step - loss: 0.0198 - acc: 0.9950 - val_loss: 0.1215 - val_acc: 0.9828</pre>\r\n\r\n    <p>В следующей главе — оценка модели и получение предсказаний для новых данных.</p>\r\n</div>",
                    Position = 9,
                    DurationMinutes = 18,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.11",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Оценка и прогнозирование с помощью модели",
                    Slug = "keras-model-evaluation-and-model-prediction",
                    Body = "<div>\r\n    <img />\r\n\r\n    <p>В этой главе рассматривается оценка модели и предсказание модели в Keras.</p>\r\n\r\n    <h3>Оценка модели</h3>\r\n\r\n    <p>Оценка — это процесс во время разработки модели, позволяющий проверить, насколько модель подходит для\r\n        поставленной задачи и соответствующих данных. Keras предоставляет функцию <b>evaluate</b>, которая выполняет\r\n        оценку модели. У неё три основных аргумента:</p>\r\n    <ul>\r\n        <li>тестовые данные</li>\r\n        <li>метки тестовых данных</li>\r\n        <li><b>verbose</b> — true или false</li>\r\n    </ul>\r\n\r\n    <p>Оценим модель, которую мы создали в предыдущей главе, используя тестовые данные.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nscore = model.evaluate(x_test, y_test, verbose = 0)\r\nprint('Test loss:', score[0])\r\nprint('Test accuracy:', score[1])</pre>\r\n\r\n    <p>Выполнение приведённого выше кода выдаст следующую информацию.</p>\r\n    <pre data-editor=\"output\">0</pre>\r\n\r\n    <p>Точность на тесте составляет 98.28%. Мы создали хорошую модель для распознавания рукописных цифр. С положительной\r\n        стороны, всё ещё можно попытаться улучшить модель.</p>\r\n\r\n    <h3>Предсказание модели</h3>\r\n\r\n    <p>Предсказание — это конечный шаг и ожидаемый результат создания модели. Keras предоставляет метод <b>predict</b>\r\n        для получения предсказаний обученной модели. Сигнатура метода predict выглядит следующим образом:</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\npredict(\r\n   x,\r\n   batch_size = None,\r\n   verbose = 0,\r\n   steps = None,\r\n   callbacks = None,\r\n   max_queue_size = 10,\r\n   workers = 1,\r\n   use_multiprocessing = False\r\n)</pre>\r\n\r\n    <p>Здесь все аргументы необязательны, кроме первого, который относится к неизвестным входным данным. Форма данных\r\n        должна сохраняться, чтобы получить корректное предсказание.</p>\r\n\r\n    <p>Выполним предсказание для нашей MLP-модели, созданной в предыдущей главе, используя код ниже −</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\npred = model.predict(x_test)\r\npred = np.argmax(pred, axis = 1)[:5]\r\nlabel = np.argmax(y_test, axis = 1)[:5]\r\n\r\nprint(pred)\r\nprint(label)</pre>\r\n\r\n    <p>Здесь:</p>\r\n    <ul>\r\n        <li><b>Строка 1</b> — вызывает функцию predict, используя тестовые данные.</li>\r\n        <li><b>Строка 2</b> — получает первые пять предсказаний.</li>\r\n        <li><b>Строка 3</b> — получает первые пять меток тестовых данных.</li>\r\n        <li><b>Строки 5–6</b> — печатают предсказание и реальную метку.</li>\r\n    </ul>\r\n\r\n    <p>Вывод вышеуказанного приложения выглядит следующим образом −</p>\r\n    <pre data-editor=\"output\">\r\n[7 2 1 0 4]\r\n[7 2 1 0 4]</pre>\r\n\r\n    <p>Массивы идентичны, что указывает на то, что наша модель правильно предсказывает первые пять изображений.</p>\r\n</div>",
                    Position = 10,
                    DurationMinutes = 6,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.12",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Сверточная нейронная сеть",
                    Slug = "keras-convolution-neural-network",
                    Body = "<div>\r\n    <img />\r\n\r\n    <p>Давайте модифицируем модель из MLP в сверточную нейронную сеть (CNN) для задачи распознавания цифр, рассмотренной\r\n        ранее.</p>\r\n\r\n    <p>CNN можно представить примерно так —</p>\r\n\r\n    <img />\r\n\r\n    <h3>Ключевые особенности модели</h3>\r\n    <ul>\r\n        <li>Входной слой состоит из значений формы (1, 8, 28).</li>\r\n        <li>Первый слой — <b>Conv2D</b> с 32 фильтрами и активацией relu, размер ядра (3,3).</li>\r\n        <li>Второй слой — <b>Conv2D</b> с 64 фильтрами и активацией relu, размер ядра (3,3).</li>\r\n        <li>Третий слой — <b>MaxPooling2D</b> с размером пула (2,2).</li>\r\n        <li>Пятый слой — <b>Flatten</b> для выравнивания входа в одномерный вектор.</li>\r\n        <li>Шестой слой — <b>Dense</b> из 128 нейронов с активацией relu.</li>\r\n        <li>Седьмой слой — <b>Dropout</b> с вероятностью 0.5.</li>\r\n        <li>Восьмой (финальный) слой — <b>Dense</b> из 10 нейронов с активацией softmax.</li>\r\n        <li>Используется <b>categorical_crossentropy</b> как функция потерь.</li>\r\n        <li>Оптимизатор: <b>Adadelta()</b>.</li>\r\n        <li>Метрика: <b>accuracy</b>.</li>\r\n        <li>Размер батча: <b>128</b>.</li>\r\n        <li>Эпохи: <b>20</b>.</li>\r\n    </ul>\r\n\r\n    <h3>Шаг 1 − Импорт модулей</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nimport keras\r\nfrom keras.datasets import mnist\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Dense, Dropout, Flatten\r\nfrom keras.layers import Conv2D, MaxPooling2D\r\nfrom keras import backend as K\r\nimport numpy as np</pre>\r\n\r\n    <h3>Шаг 2 − Загрузка данных</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n(x_train, y_train), (x_test, y_test) = mnist.load_data()</pre>\r\n\r\n    <h3>Шаг 3 − Обработка данных</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nimg_rows, img_cols = 28, 28\r\nif K.image_data_format() == 'channels_first':\r\n   x_train = x_train.reshape(x_train.shape[0], 1, img_rows, img_cols)\r\n   x_test = x_test.reshape(x_test.shape[0], 1, img_rows, img_cols)\r\n   input_shape = (1, img_rows, img_cols)\r\nelse:\r\n   x_train = x_train.reshape(x_train.shape[0], img_rows, img_cols, 1)\r\n   x_test = x_test.reshape(x_test.shape[0], img_rows, img_cols, 1)\r\n   input_shape = (img_rows, img_cols, 1)\r\nx_train = x_train.astype('float32')\r\nx_test = x_test.astype('float32')\r\nx_train /= 255\r\nx_test /= 255\r\n\r\ny_train = keras.utils.to_categorical(y_train, 10)\r\ny_test = keras.utils.to_categorical(y_test, 10) </pre>\r\n\r\n    <h3>Шаг 4 − Создание модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel = Sequential()\r\nmodel.add(Conv2D(32, kernel_size = (3, 3),\r\n   activation = 'relu', input_shape = input_shape))\r\nmodel.add(Conv2D(64, (3, 3), activation = 'relu'))\r\nmodel.add(MaxPooling2D(pool_size = (2, 2)))\r\nmodel.add(Dropout(0.25))\r\nmodel.add(Flatten())\r\nmodel.add(Dense(128, activation = 'relu'))\r\nmodel.add(Dropout(0.5))\r\nmodel.add(Dense(10, activation = 'softmax'))</pre>\r\n\r\n    <h3>Шаг 5 − Компиляция модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel.compile(loss = keras.losses.categorical_crossentropy,\r\n   optimizer = keras.optimizers.Adadelta(), metrics = ['accuracy'])</pre>\r\n\r\n    <h3>Шаг 6 − Обучение модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel.fit(\r\n   x_train, y_train,\r\n   batch_size = 128,\r\n   epochs = 12,\r\n   verbose = 1,\r\n   validation_data = (x_test, y_test)\r\n)</pre>\r\n\r\n    <h3>Ожидаемый вывод обучения</h3>\r\n    <pre data-editor=\"output\">\r\nTrain on 60000 samples, validate on 10000 samples\r\nEpoch 1/12\r\n60000/60000 [==============================] - 84s 1ms/step - loss: 0.2687 - acc: 0.9173 - val_loss: 0.0549 - val_acc: 0.9827\r\nEpoch 2/12\r\n60000/60000 [==============================] - 86s 1ms/step - loss: 0.0899 - acc: 0.9737 - val_loss: 0.0452 - val_acc: 0.9845\r\nEpoch 3/12\r\n60000/60000 [==============================] - 83s 1ms/step - loss: 0.0666 - acc: 0.9804 - val_loss: 0.0362 - val_acc: 0.9879\r\nEpoch 4/12\r\n60000/60000 [==============================] - 81s 1ms/step - loss: 0.0564 - acc: 0.9830 - val_loss: 0.0336 - val_acc: 0.9890\r\nEpoch 5/12\r\n60000/60000 [==============================] - 86s 1ms/step - loss: 0.0472 - acc: 0.9861 - val_loss: 0.0312 - val_acc: 0.9901\r\nEpoch 6/12\r\n60000/60000 [==============================] - 83s 1ms/step - loss: 0.0414 - acc: 0.9877 - val_loss: 0.0306 - val_acc: 0.9902\r\nEpoch 7/12\r\n60000/60000 [==============================] - 89s 1ms/step - loss: 0.0375 - acc: 0.9883 - val_loss: 0.0281 - val_acc: 0.9906\r\nEpoch 8/12\r\n60000/60000 [==============================] - 91s 2ms/step - loss: 0.0339 - acc: 0.9893 - val_loss: 0.0280 - val_acc: 0.9912\r\nEpoch 9/12\r\n60000/60000 [==============================] - 89s 1ms/step - loss: 0.0325 - acc: 0.9901 - val_loss: 0.0260 - val_acc: 0.9909\r\nEpoch 10/12\r\n60000/60000 [==============================] - 89s 1ms/step - loss: 0.0284 - acc: 0.9910 - val_loss: 0.0250 - val_acc: 0.9919\r\nEpoch 11/12\r\n60000/60000 [==============================] - 86s 1ms/step - loss: 0.0287 - acc: 0.9907 - val_loss: 0.0264 - val_acc: 0.9916\r\nEpoch 12/12\r\n60000/60000 [==============================] - 86s 1ms/step - loss: 0.0265 - acc: 0.9920 - val_loss: 0.0249 - val_acc: 0.9922</pre>\r\n\r\n    <h3>Шаг 7 − Оценка модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nscore = model.evaluate(x_test, y_test, verbose = 0)\r\n\r\nprint('Test loss:', score[0])\r\nprint('Test accuracy:', score[1]) </pre>\r\n\r\n    <h3>Ожидаемый вывод оценки</h3>\r\n    <pre data-editor=\"output\">\r\nTest loss: 0.024936060590433316\r\nTest accuracy: 0.9922</pre>\r\n\r\n    <h3>Шаг 8 − Предсказание</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\npred = model.predict(x_test)\r\npred = np.argmax(pred, axis = 1)[:5]\r\nlabel = np.argmax(y_test, axis = 1)[:5]\r\n\r\nprint(pred)\r\nprint(label) </pre>\r\n\r\n    <h3>Ожидаемый вывод предсказания</h3>\r\n    <pre data-editor=\"output\">\r\n[7 2 1 0 4]\r\n[7 2 1 0 4]</pre>\r\n</div>",
                    Position = 11,
                    DurationMinutes = 16,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.13",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Регрессивное прогнозиорвание с MPL",
                    Slug = "keras-regression-prediction-using-mpl",
                    Body = "<div>\r\n    <img />\r\n\r\n    <p>В этой главе мы напишем простой MLP (многослойный персептрон) для задачи регрессионного предсказания. До сих пор\r\n        мы\r\n        рассматривали задачи классификации; теперь попробуем предсказать следующее возможное значение, анализируя ранее\r\n        наблюдаемые (непрерывные) значения и факторы, которые на них влияют.</p>\r\n\r\n    <p>Регрессионный MLP можно представить примерно так —</p>\r\n\r\n    <img />\r\n\r\n    <h3>Основные характеристики модели</h3>\r\n    <ul>\r\n        <li>Входной слой состоит из 13 значений (форма (13,)).</li>\r\n        <li>Первый слой Dense: 64 единицы, активация relu, kernel_initializer = 'normal'.</li>\r\n        <li>Второй слой Dense: 64 единицы, активация relu.</li>\r\n        <li>Выходной слой Dense: 1 единица.</li>\r\n        <li>Функция потерь: mse (mean squared error).</li>\r\n        <li>Оптимизатор: RMSprop.</li>\r\n        <li>Метрика: mean_absolute_error.</li>\r\n        <li>Размер батча: 128.</li>\r\n        <li>Эпохи: 500.</li>\r\n    </ul>\r\n\r\n    <h3>Шаг 1 − Импорт модулей</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nimport keras\r\nfrom keras.datasets import boston_housing\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Dense\r\nfrom keras.optimizers import RMSprop\r\nfrom keras.callbacks import EarlyStopping\r\nfrom sklearn import preprocessing\r\nfrom sklearn.preprocessing import scale</pre>\r\n\r\n    <h3>Шаг 2 − Загрузка данных</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n(x_train, y_train), (x_test, y_test) = boston_housing.load_data()</pre>\r\n\r\n    <p>Здесь boston_housing — датасет, предоставляемый Keras; он содержит информацию о домах в районе Бостона, где\r\n        каждый\r\n        объект описывается 13 признаками.</p>\r\n\r\n    <h3>Шаг 3 − Обработка данных</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nx_train_scaled = preprocessing.scale(x_train)\r\nscaler = preprocessing.StandardScaler().fit(x_train)\r\nx_test_scaled = scaler.transform(x_test)</pre>\r\n\r\n    <p>Мы нормализовали тренировочные данные с помощью <code>sklearn.preprocessing.scale</code>.\r\n        <code>StandardScaler().fit</code>\r\n        вычисляет среднее и стандартное отклонение на тренировочных данных, затем мы применяем эти параметры к тестовым\r\n        данным\r\n        через <code>transform</code>, чтобы тестовые данные были масштабированы теми же настройками, что и\r\n        тренировочные.\r\n    </p>\r\n\r\n    <h3>Шаг 4 − Создание модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel = Sequential()\r\nmodel.add(Dense(64, kernel_initializer = 'normal', activation = 'relu',\r\n    input_shape = (13,)))\r\nmodel.add(Dense(64, activation = 'relu'))\r\nmodel.add(Dense(1))</pre>\r\n\r\n    <h3>Шаг 5 − Компиляция модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel.compile(\r\n   loss = 'mse',\r\n   optimizer = RMSprop(),\r\n   metrics = ['mean_absolute_error']\r\n)</pre>\r\n\r\n    <h3>Шаг 6 − Обучение модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nhistory = model.fit(\r\n   x_train_scaled, y_train,\r\n   batch_size = 128,\r\n   epochs = 500,\r\n   verbose = 1,\r\n   validation_split = 0.2,\r\n   callbacks = [EarlyStopping(monitor = 'val_loss', patience = 20)]\r\n)</pre>\r\n\r\n    <p>Здесь используется callback <code>EarlyStopping</code>, который отслеживает значение валидационной потери\r\n        (<code>val_loss</code>)\r\n        и прерывает обучение, если улучшений не происходит в течение <code>patience</code> эпох.</p>\r\n\r\n    <p>Выполнение приложения выведет в лог информацию об обучении, например:</p>\r\n    <pre data-editor=\"output\">\r\nTrain on 323 samples, validate on 81 samples\r\nEpoch 1/500\r\n... - loss: 562.3129 - mean_absolute_error: 21.8575 - val_loss: 621.6523 - val_mean_absolute_error: 23.1730\r\n...\r\nEpoch 143/500\r\n... - loss: 8.1004 - mean_absolute_error: 2.0002 - val_loss: 14.6286 - val_mean_absolute_error: 2.5904\r\nEpoch 144/500\r\n... - loss: 8.0300 - mean_absolute_error: 1.9683 - val_loss: 14.5949 - val_mean_absolute_error: 2.5843\r\nEpoch 145/500\r\n... - loss: 7.8704 - mean_absolute_error: 1.9313 - val_loss: 14.3770 - val_mean_absolute_error: 2.4996</pre>\r\n\r\n    <h3>Шаг 7 − Оценка модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nscore = model.evaluate(x_test_scaled, y_test, verbose = 0)\r\nprint('Test loss:', score[0])\r\nprint('Test accuracy:', score[1])</pre>\r\n\r\n    <p>Пример вывода оценки:</p>\r\n    <pre data-editor=\"output\">\r\nTest loss: 21.928471583946077\r\nTest accuracy: 2.9599233234629914</pre>\r\n\r\n    <h3>Шаг 8 − Предсказание</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nprediction = model.predict(x_test_scaled)\r\nprint(prediction.flatten())\r\nprint(y_test)</pre>\r\n\r\n    <p>Пример вывода предсказаний и истинных значений (обрезано для компактности):</p>\r\n    <pre data-editor=\"output\">\r\n[ 7.5612316 17.583357 21.09344 31.859276 25.055613 ... 20.248306]\r\n[ 7.2 18.8 19. 27. 22.2 ... 25. ]</pre>\r\n\r\n    <p>Выходы двух массивов показывают разницу примерно в 10–30%, что указывает на то, что модель предсказывает в\r\n        разумном диапазоне.</p>\r\n</div>",
                    Position = 12,
                    DurationMinutes = 16,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.14",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Прогнозирование временных рядов с LSTM RNN",
                    Slug = "keras-time-series-prediction-using-lstm-rnn",
                    Body = "<div>\r\n    <img />\r\n\r\n    <p>В этой главе создадим простой RNN на базе LSTM для анализа последовательностей. Последовательность — это набор\r\n        значений,\r\n        где каждое значение соответствует определённому моменту времени. Рассмотрим простой пример чтения предложения.\r\n        Чтение\r\n        и понимание предложения включает последовательное чтение слов и попытку понять каждое слово в данном контексте,\r\n        а затем\r\n        понять смысл всего предложения — например, положительную или отрицательную тональность.</p>\r\n\r\n    <p>Здесь слова рассматриваются как значения: первое значение — первое слово, второе значение — второе слово и т.д.\r\n        Порядок\r\n        строго важен. Анализ последовательностей часто используется в обработке естественного языка для анализа\r\n        тональности\r\n        текста.</p>\r\n\r\n    <p>Создадим модель LSTM для анализа отзывов с IMDB и определения их положительной/отрицательной тональности.</p>\r\n\r\n    <p>Модель для анализа последовательностей можно представить так −</p>\r\n\r\n    <img />\r\n\r\n    <h3>Ключевые особенности модели</h3>\r\n    <ul>\r\n        <li>Входной слой — Embedding с 128 признаками.</li>\r\n        <li>Первый слой LSTM: 128 единиц, dropout и recurrent_dropout установлены в 0.2.</li>\r\n        <li>Выходной слой Dense: 1 единица с сигмоидной активацией.</li>\r\n        <li>Функция потерь: <b>binary_crossentropy</b>.</li>\r\n        <li>Оптимизатор: <b>adam</b>.</li>\r\n        <li>Метрика: <b>accuracy</b>.</li>\r\n        <li>batch_size = 32.</li>\r\n        <li>epochs = 15.</li>\r\n        <li>maxlen (максимальная длина отзыва) = 80.</li>\r\n        <li>num_words (максимальное число слов в словаре) = 2000.</li>\r\n    </ul>\r\n\r\n    <h3>Шаг 1 − Импорт модулей</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nfrom keras.preprocessing import sequence\r\nfrom keras.models import Sequential\r\nfrom keras.layers import Dense, Embedding\r\nfrom keras.layers import LSTM\r\nfrom keras.datasets import imdb</pre>\r\n\r\n    <h3>Шаг 2 − Загрузка данных</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n(x_train, y_train), (x_test, y_test) = imdb.load_data(num_words = 2000)</pre>\r\n\r\n    <p>Здесь:</p>\r\n    <ul>\r\n        <li><b>imdb</b> — датасет, предоставляемый Keras, содержащий коллекцию фильмов и их отзывов.</li>\r\n        <li><b>num_words</b> — максимальное число слов, учитываемых в отзывах (частота слов ограничивается этим числом).\r\n        </li>\r\n    </ul>\r\n\r\n    <h3>Шаг 3 − Обработка данных</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nx_train = sequence.pad_sequences(x_train, maxlen=80)\r\nx_test = sequence.pad_sequences(x_test, maxlen=80)</pre>\r\n\r\n    <p>Здесь <b>sequence.pad_sequences</b> преобразует список входных последовательностей в 2D NumPy-массив формы\r\n        (число_образцов, timesteps).\r\n        По сути, добавляет концепцию временных шагов в данные, генерируя последовательности длины <b>maxlen</b>.</p>\r\n\r\n    <h3>Шаг 4 − Создание модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel = Sequential()\r\nmodel.add(Embedding(2000, 128))\r\nmodel.add(LSTM(128, dropout = 0.2, recurrent_dropout = 0.2))\r\nmodel.add(Dense(1, activation = 'sigmoid'))</pre>\r\n\r\n    <p>Здесь в качестве входного слоя используется Embedding, затем LSTM, и в конце — выходной Dense-слой.</p>\r\n\r\n    <h3>Шаг 5 − Компиляция модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel.compile(loss = 'binary_crossentropy',\r\n   optimizer = 'adam', metrics = ['accuracy'])</pre>\r\n\r\n    <h3>Шаг 6 − Обучение модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nmodel.fit(\r\n   x_train, y_train,\r\n   batch_size = 32,\r\n   epochs = 15,\r\n   validation_data = (x_test, y_test)\r\n)</pre>\r\n\r\n    <h3>Ожидаемый вывод при обучении</h3>\r\n    <pre data-editor=\"output\">\r\nEpoch 1/15\r\n2019-09-24 01:19:01.151247: I tensorflow/core/platform/cpu_feature_guard.cc:142]\r\nYour CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2\r\n25000/25000 [==============================] - 101s 4ms/step - loss: 0.4707 - acc: 0.7716 - val_loss: 0.3769 - val_acc: 0.8349\r\nEpoch 2/15\r\n25000/25000 [==============================] - 95s 4ms/step - loss: 0.3058 - acc: 0.8756 - val_loss: 0.3763 - val_acc: 0.8350\r\nEpoch 3/15\r\n25000/25000 [==============================] - 91s 4ms/step - loss: 0.2100 - acc: 0.9178 - val_loss: 0.5065 - val_acc: 0.8110\r\nEpoch 4/15\r\n25000/25000 [==============================] - 90s 4ms/step - loss: 0.1394 - acc: 0.9495 - val_loss: 0.6046 - val_acc: 0.8146\r\nEpoch 5/15\r\n25000/25000 [==============================] - 90s 4ms/step - loss: 0.0973 - acc: 0.9652 - val_loss: 0.5969 - val_acc: 0.8147\r\nEpoch 6/15\r\n25000/25000 [==============================] - 98s 4ms/step - loss: 0.0759 - acc: 0.9730 - val_loss: 0.6368 - val_acc: 0.8208\r\nEpoch 7/15\r\n25000/25000 [==============================] - 95s 4ms/step - loss: 0.0578 - acc: 0.9811 - val_loss: 0.6657 - val_acc: 0.8184\r\nEpoch 8/15\r\n25000/25000 [==============================] - 97s 4ms/step - loss: 0.0448 - acc: 0.9850 - val_loss: 0.7452 - val_acc: 0.8136\r\nEpoch 9/15\r\n25000/25000 [==============================] - 95s 4ms/step - loss: 0.0324 - acc: 0.9894 - val_loss: 0.7616 - val_acc: 0.8162\r\nEpoch 10/15\r\n25000/25000 [==============================] - 100s 4ms/step - loss: 0.0247 - acc: 0.9922 - val_loss: 0.9654 - val_acc: 0.8148\r\nEpoch 11/15\r\n25000/25000 [==============================] - 99s 4ms/step - loss: 0.0169 - acc: 0.9946 - val_loss: 1.0013 - val_acc: 0.8104\r\nEpoch 12/15\r\n25000/25000 [==============================] - 90s 4ms/step - loss: 0.0154 - acc: 0.9948 - val_loss: 1.0316 - val_acc: 0.8100\r\nEpoch 13/15\r\n25000/25000 [==============================] - 89s 4ms/step - loss: 0.0113 - acc: 0.9963 - val_loss: 1.1138 - val_acc: 0.8108\r\nEpoch 14/15\r\n25000/25000 [==============================] - 89s 4ms/step - loss: 0.0106 - acc: 0.9971 - val_loss: 1.0538 - val_acc: 0.8102\r\nEpoch 15/15\r\n25000/25000 [==============================] - 89s 4ms/step - loss: 0.0090 - acc: 0.9972 - val_loss: 1.1453 - val_acc: 0.8129\r\n25000/25000 [==============================] - 10s 390us/step</pre>\r\n\r\n    <h3>Шаг 7 − Оценка модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nscore, acc = model.evaluate(x_test, y_test, batch_size = 32)\r\n\r\nprint('Test score:', score)\r\nprint('Test accuracy:', acc) </pre>\r\n\r\n    <h3>Ожидаемый вывод оценки</h3>\r\n    <pre data-editor=\"output\">\r\nTest score: 1.145306069601178\r\nTest accuracy: 0.81292</pre>\r\n</div>",
                    Position = 13,
                    DurationMinutes = 16,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.15",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Приложения",
                    Slug = "keras-layers",
                    Body = "<div>\r\n    <img />\r\n\r\n    <p>Keras-модуль приложений (applications) предоставляет заранее обученные модели для глубоких нейронных сетей.\r\n        Модели\r\n        Keras используются для предсказаний, извлечения признаков и дообучения (fine-tuning). В этой главе подробно\r\n        рассматривается модуль приложений Keras.</p>\r\n\r\n    <h3>Предобученные модели</h3>\r\n    <p>Обученная модель состоит из двух частей: архитектуры модели (model Architecture) и весов модели (model Weights).\r\n        Файл с весами обычно большой — его необходимо загрузить (и при необходимости извлечь) из базы данных ImageNet.\r\n        Ниже перечислены некоторые из популярных предобученных моделей:</p>\r\n\r\n    <ul>\r\n        <li>ResNet</li>\r\n        <li>VGG16</li>\r\n        <li>MobileNet</li>\r\n        <li>InceptionResNetV2</li>\r\n        <li>InceptionV3</li>\r\n    </ul>\r\n\r\n    <h3>Загрузка модели</h3>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nimport keras\r\nimport numpy as np\r\n\r\nfrom keras.applications import vgg16, inception_v3, resnet50, mobilenet\r\n\r\n# Load the VGG model\r\nvgg_model = vgg16.VGG16(weights = 'imagenet')\r\n\r\n# Load the Inception_V3 model\r\ninception_model = inception_v3.InceptionV3(weights = 'imagenet')\r\n\r\n# Load the ResNet50 model\r\nresnet_model = resnet50.ResNet50(weights = 'imagenet')\r\n\r\n# Load the MobileNet model\r\nmobilenet_model = mobilenet.MobileNet(weights = 'imagenet')</pre>\r\n\r\n    <p>После загрузки модели её можно сразу использовать для предсказаний, извлечения признаков или дообучения на\r\n        собственной выборке. В следующих главах рассматриваются отдельные предобученные модели более подробно.</p>\r\n</div>",
                    Position = 14,
                    DurationMinutes = 16,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.16",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Прогнозирование в реальном времени с использованием модели ResNet",
                    Slug = "keras-layers",
                    Body = "<div>\r\n    <img alt=\"Keras / ResNet\" />\r\n\r\n    <p>ResNet — предобученная модель, обученная на наборе данных ImageNet. Веса модели ResNet предобучены на ImageNet.\r\n        Синтаксис для загрузки модели выглядит следующим образом:</p>\r\n\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nkeras.applications.resnet.ResNet50 (\r\n   include_top = True,\r\n   weights = 'imagenet',\r\n   input_tensor = None,\r\n   input_shape = None,\r\n   pooling = None,\r\n   classes = 1000\r\n)</pre>\r\n\r\n    <p>Здесь:</p>\r\n    <ul>\r\n        <li><b>include_top</b> — указывает на полносвязный (fully-connected) слой в верхней части сети.</li>\r\n        <li><b>weights</b> — указывает на предобученные веса (в данном случае 'imagenet').</li>\r\n        <li><b>input_tensor</b> — необязательный Keras-тензор, используемый как вход для модели.</li>\r\n        <li><b>input_shape</b> — необязательное описание формы входа. Размер по умолчанию для этой модели — 224×224.\r\n        </li>\r\n        <li><b>pooling</b> — опция объединяющего слоя при отсутствии верхней части (например, 'avg' или 'max').</li>\r\n        <li><b>classes</b> — необязательное количество классов для классификации изображений (по умолчанию 1000 для\r\n            ImageNet).</li>\r\n    </ul>\r\n\r\n    <h3>Поясним работу модели на простом примере</h3>\r\n\r\n    <h4>Шаг 1 — импорт модулей</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n# Импорт необходимых модулей\r\nimport PIL\r\nfrom keras.preprocessing.image import load_img\r\nfrom keras.preprocessing.image import img_to_array\r\nfrom keras.applications.imagenet_utils import decode_predictions\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nfrom keras.applications.resnet50 import ResNet50\r\nfrom keras.applications import resnet50</pre>\r\n\r\n    <h4>Шаг 2 — выбор входного изображения</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n# Пример: используем файл banana.jpg\r\nfilename = 'banana.jpg'\r\n\r\n# загрузить изображение через Keras (PIL) и изменить размер до 224x224\r\noriginal = load_img(filename, target_size=(224, 224))\r\nprint('PIL image size', original.size)\r\n# отобразить изображение (опционально)\r\nplt.imshow(original)\r\nplt.show()</pre>\r\n\r\n    <h4>Шаг 3 — преобразование изображения в NumPy-массив</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n# преобразовать PIL-изображение в numpy-массив\r\nnumpy_image = img_to_array(original)\r\n\r\n# проверить форму массива\r\nprint('numpy array size', numpy_image.shape)  # ожидается (224, 224, 3)\r\n\r\n# добавить ось для размера батча: (1, 224, 224, 3)\r\nimage_batch = np.expand_dims(numpy_image, axis=0)\r\nprint('image batch size', image_batch.shape)</pre>\r\n\r\n    <h4>Шаг 4 — подготовка изображения и предсказание</h4>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\n# подготовить изображение в формате, ожидаемом resnet50\r\nprocessed_image = resnet50.preprocess_input(image_batch.copy())\r\n\r\n# создать модель ResNet50 с весами ImageNet\r\nresnet_model = resnet50.ResNet50(weights='imagenet')\r\n\r\n# выполнить предсказание — модель вернёт вероятности по 1000 классам\r\npredictions = resnet_model.predict(processed_image)\r\n\r\n# преобразовать вероятности в человекочитаемые метки\r\nlabel = decode_predictions(predictions)\r\nprint(label)</pre>\r\n\r\n    <h4>Ожидаемый пример вывода</h4>\r\n    <pre data-editor=\"output\">\r\n[\r\n   [\r\n      ('n07753592', 'banana', 0.99229723),\r\n      ('n03532672', 'hook', 0.0014551596),\r\n      ('n03970156', 'plunger', 0.0010738898),\r\n      ('n07753113', 'fig', 0.0009359837),\r\n      ('n03109150', 'corkscrew', 0.00028538404)\r\n   ]\r\n]</pre>\r\n\r\n    <p>В этом примере модель правильно определила изображение как banana (банан) с высокой вероятностью.\r\n    </p>\r\n</div>",
                    Position = 15,
                    DurationMinutes = 16,
                    IsPublished = true,
                    IsFreePreview = true
                },
                new
                {
                    Id = "keras-for-beginners-module-1.17",
                    ModuleId = "keras-for-beginners-main",
                    Title = "Keras - Предобученные модели",
                    Slug = "keras-layers",
                    Body = "<div>\r\n    <img alt=\"Keras - Pre-Trained Models\" />\r\n\r\n    <p>В этой главе мы рассмотрим предобученные модели в Keras. Начнём с VGG16.</p>\r\n\r\n    <h3>VGG16</h3>\r\n    <p>VGG16 — ещё одна предобученная модель. Она также обучена на наборе данных ImageNet. Синтаксис для загрузки модели\r\n        выглядит следующим образом —</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nkeras.applications.vgg16.VGG16(\r\n   include_top = True,\r\n   weights = 'imagenet',\r\n   input_tensor = None,\r\n   input_shape = None,\r\n   pooling = None,\r\n   classes = 1000\r\n)</pre>\r\n    <p>Размер входного изображения по умолчанию для этой модели — 224×224.</p>\r\n\r\n    <h3>MobileNetV2</h3>\r\n    <p>MobileNetV2 — ещё одна предобученная модель. Она также обучена на ImageNet.</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nkeras.applications.mobilenet_v2.MobileNetV2 (\r\n   input_shape = None,\r\n   alpha = 1.0,\r\n   include_top = True,\r\n   weights = 'imagenet',\r\n   input_tensor = None,\r\n   pooling = None,\r\n   classes = 1000\r\n)</pre>\r\n    <p>Здесь <b>alpha</b> управляет шириной сети. Если значение меньше 1 — уменьшается число фильтров в каждом слое.\r\n        Если значение больше 1 — увеличивается число фильтров. При <code>alpha = 1</code> используются значения по\r\n        умолчанию, указанные в оригинальной статье.</p>\r\n    <p>Размер входного изображения по умолчанию для этой модели — 224×224.</p>\r\n\r\n    <h3>InceptionResNetV2</h3>\r\n    <p>InceptionResNetV2 — ещё одна предобученная модель. Она также обучена на ImageNet. Синтаксис для загрузки модели:\r\n    </p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nkeras.applications.inception_resnet_v2.InceptionResNetV2 (\r\n   include_top = True,\r\n   weights = 'imagenet',\r\n   input_tensor = None,\r\n   input_shape = None,\r\n   pooling = None,\r\n   classes = 1000\r\n)</pre>\r\n    <p>Эта модель может быть построена как с форматом данных <b>channels_first</b> (каналы, высота, ширина), так и\r\n        с форматом <b>channels_last</b> (высота, ширина, каналы).</p>\r\n    <p>Размер входного изображения по умолчанию для этой модели — 299×299.</p>\r\n\r\n    <h3>InceptionV3</h3>\r\n    <p>InceptionV3 — ещё одна предобученная модель, обученная на ImageNet. Синтаксис для загрузки модели:</p>\r\n    <pre data-editor=\"code\" data-ln=\"python\">\r\nkeras.applications.inception_v3.InceptionV3 (\r\n   include_top = True,\r\n   weights = 'imagenet',\r\n   input_tensor = None,\r\n   input_shape = None,\r\n   pooling = None,\r\n   classes = 1000\r\n)</pre>\r\n    <p>Размер входного изображения по умолчанию для этой модели — 299×299.</p>\r\n\r\n    <h3>Заключение</h3>\r\n    <p>Keras прост в использовании, расширяем и удобен для реализации нейронных сетей высокого уровня абстракции. Keras\r\n        — оптимальный выбор для построения глубоких моделей.</p>\r\n</div>",
                    Position = 16,
                    DurationMinutes = 16,
                    IsPublished = true,
                    IsFreePreview = true
                }
            );

            //// Ресурсы (несколько примеров)
            //builder.Entity<LessonResource>().HasData(
            //    new
            //    {
            //        Id = "c3333333-3333-3333-3333-ccccccccccc4",
            //        LessonId = "b2222222-2222-2222-2222-bbbbbbbbbbb4", // control-flow
            //        Url = "https://docs.microsoft.com/dotnet/csharp/programming-guide/inside-a-program",
            //        ResourceType = "article",
            //        Title = "Документация Microsoft: Inside a Program",
            //        Position = 0
            //    },
            //    new
            //    {
            //        Id = "c3333333-3333-3333-3333-ccccccccccc5",
            //        LessonId = "b2222222-2222-2222-2222-bbbbbbbbbbb8", // inheritance
            //        Url = "https://docs.microsoft.com/dotnet/csharp/fundamentals/object-oriented/",
            //        ResourceType = "article",
            //        Title = "OOP в C# — официальная документация",
            //        Position = 0
            //    },
            //    new
            //    {
            //        Id = "c3333333-3333-3333-3333-ccccccccccc6",
            //        LessonId = "b2222222-2222-2222-2222-bbbbbbbbb12", // linq-intro
            //        Url = "https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/",
            //        ResourceType = "article",
            //        Title = "LINQ — руководство",
            //        Position = 0
            //    },
            //    new
            //    {
            //        Id = "c3333333-3333-3333-3333-ccccccccccc7",
            //        LessonId = "b2222222-2222-2222-2222-bbbbbbbbb17", // http-httpclient
            //        Url = "https://learn.microsoft.com/dotnet/api/system.net.http.httpclient",
            //        ResourceType = "article",
            //        Title = "HttpClient — справочник",
            //        Position = 0
            //    },
            //    new
            //    {
            //        Id = "c3333333-3333-3333-3333-ccccccccccc8",
            //        LessonId = "b2222222-2222-2222-2222-bbbbbbbbb20", // efcore
            //        Url = "https://learn.microsoft.com/ef/core/",
            //        ResourceType = "article",
            //        Title = "EF Core — официальная документация",
            //        Position = 0
            //    }
            //);


        }
    }
}
